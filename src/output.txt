1 : End_tag_open_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(NextInputCharacter(1))

-- chara: ASCII alpha --
Create a new end tag token, set its tag name to the empty string. Reconsume in the tag name state. 
  | Create a new end tag token and set its tag name to the empty string. you Reconsume in the Tag_name_state. 
List(List((1,CHAIN1-["a new end tag token" in sentence 1, "its" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(1,a,a)), Leaf(JJ,Token(1,new,new)), Leaf(NN,Token(1,end,end)), Leaf(NN,Token(1,tag,tag)), Leaf(NN,Token(1,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,set,set)), Node(NP,List(Leaf(PRPD,Token(1,its,its)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Tag_name_state,tag_name_state))))))))))))

 -> Create(NewEndTagToken,x_1)
 -> Set(INameOf(IVariable(x_1)),CString())
 -> Reconsume(StateName(Tag_name_state))

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is a missing-end-tag-name parse error. Switch to the data state.
  | This is a missing_end_tag_name parse error. you Switch to the Data_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_end_tag_name,missing_end_tag_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))

 -> Error(missing_end_tag_name parse error)
 -> Switch(StateName(Data_state))

-- chara: EOF --
This is an eof-before-tag-name parse error. Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token and an end-of-file token. 
  | This is an eof_before_tag_name parse error. you Emit a U_003C LESS_THAN SIGN character token, a U_002F SOLIDUS character token and an end_of_file token. 
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_before_tag_name,eof_before_tag_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Error(eof_before_tag_name parse error)
 -> Emit(CString(<))
 -> Emit(CString(/))
 -> Emit(EndOfFileToken)

-- chara: Anything else --
This is an invalid-first-character-of-tag-name parse error. Create a comment token whose data is the empty string. Reconsume in the bogus comment state.
  | This is an invalid_first_character_of_tag_name parse error. Create a comment token whose data is the empty string. you Reconsume in the Bogus_comment_state.
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,invalid_first_character_of_tag_name,invalid_first_character_of_tag_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)))), Node(SBAR,List(Node(WHNP,List(Leaf(WPD,Token(-1,whose,whose)), Node(NML,List(Leaf(NNS,Token(-1,data,datum)))))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_comment_state,Bogus_comment_state))))))))))))

 -> Error(invalid_first_character_of_tag_name parse error)
 -> Create(NewCommentToken,)
 -> Reconsume(StateName(Bogus_comment_state))

ListMap(End_tag_open_state -> pState(End_tag_open_state,List(Consume(NextInputCharacter(1))),List((ASCII alpha,List(Create(NewEndTagToken,x_1), Set(INameOf(IVariable(x_1)),CString()), Reconsume(StateName(Tag_name_state)))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(missing_end_tag_name parse error), Switch(StateName(Data_state)))), (EOF,List(Error(eof_before_tag_name parse error), Emit(CString(<)), Emit(CString(/)), Emit(EndOfFileToken))), (Anything else,List(Error(invalid_first_character_of_tag_name parse error), Create(NewCommentToken,), Reconsume(StateName(Bogus_comment_state)))))))

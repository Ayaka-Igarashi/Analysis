11 : RCDATA end tag name state
-- chara: U+0009 CHARACTER TABULATION (tab) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, you treat it as per the "anything else" entry below.
List((5,CHAIN5-["the current end tag token" in sentence 1]))
List((5,CHAIN5-["it" in sentence 2]))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)))), Node(VP,List(Leaf(VBZ,Token(is,be)), Node(NP,List(Leaf(DT,Token(an,a)), Leaf(JJ,Token(appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)))), Leaf(NN,Token(token,token)))))))))), Leaf(Comma,Token(,,,)), Node(ADVP,List(Leaf(RB,Token(then,then)))), Node(VP,List(Leaf(VB,Token(switch,switch)), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Node(NML,List(Node(PP,List(Leaf(IN,Token(before,before)), Node(NP,List(Leaf(NN,Token(attribute,attribute)))))))), Leaf(NN,Token(name,name)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(Otherwise,otherwise)))), Leaf(Comma,Token(,,,)), Node(NP,List(Leaf(PRP,Token(you,you)))), Node(VP,List(Leaf(VBP,Token(treat,treat)), Node(NP,List(Leaf(PRP,Token(it,it)))), Node(ADVP,List(Leaf(RB,Token(as,as)), Node(PP,List(Leaf(IN,Token(per,per)), Node(NP,List(Leaf(DT,Token(the,the)), Node(NML,List(Leaf(LDoubleQuote,Token(",")), Node(FRAG,List(Node(NP,List(Leaf(NN,Token(anything,anything)))), Node(ADVP,List(Leaf(RB,Token(else,else)))))), Leaf(RDoubleQuote,Token(",")))), Leaf(NN,Token(entry,entry)))), Node(ADVP,List(Leaf(RB,Token(below,below)))))))))), Leaf(Dot,Token(.,.))))))
not match_s

 -> If(Bool(the_current_end_tag_token_is_an_appropriate_end_tag_token),List(Switch(the_before_attribute_name_state)),List())

-- chara: U+000A LINE FEED (LF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, you treat it as per the "anything else" entry below.
List((5,CHAIN5-["the current end tag token" in sentence 1]))
List((5,CHAIN5-["it" in sentence 2]))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)))), Node(VP,List(Leaf(VBZ,Token(is,be)), Node(NP,List(Leaf(DT,Token(an,a)), Leaf(JJ,Token(appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)))), Leaf(NN,Token(token,token)))))))))), Leaf(Comma,Token(,,,)), Node(ADVP,List(Leaf(RB,Token(then,then)))), Node(VP,List(Leaf(VB,Token(switch,switch)), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Node(NML,List(Node(PP,List(Leaf(IN,Token(before,before)), Node(NP,List(Leaf(NN,Token(attribute,attribute)))))))), Leaf(NN,Token(name,name)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(Otherwise,otherwise)))), Leaf(Comma,Token(,,,)), Node(NP,List(Leaf(PRP,Token(you,you)))), Node(VP,List(Leaf(VBP,Token(treat,treat)), Node(NP,List(Leaf(PRP,Token(it,it)))), Node(ADVP,List(Leaf(RB,Token(as,as)), Node(PP,List(Leaf(IN,Token(per,per)), Node(NP,List(Leaf(DT,Token(the,the)), Node(NML,List(Leaf(LDoubleQuote,Token(",")), Node(FRAG,List(Node(NP,List(Leaf(NN,Token(anything,anything)))), Node(ADVP,List(Leaf(RB,Token(else,else)))))), Leaf(RDoubleQuote,Token(",")))), Leaf(NN,Token(entry,entry)))), Node(ADVP,List(Leaf(RB,Token(below,below)))))))))), Leaf(Dot,Token(.,.))))))
not match_s

 -> If(Bool(the_current_end_tag_token_is_an_appropriate_end_tag_token),List(Switch(the_before_attribute_name_state)),List())

-- chara: U+000C FORM FEED (FF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, you treat it as per the "anything else" entry below.
List((5,CHAIN5-["the current end tag token" in sentence 1]))
List((5,CHAIN5-["it" in sentence 2]))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)))), Node(VP,List(Leaf(VBZ,Token(is,be)), Node(NP,List(Leaf(DT,Token(an,a)), Leaf(JJ,Token(appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)))), Leaf(NN,Token(token,token)))))))))), Leaf(Comma,Token(,,,)), Node(ADVP,List(Leaf(RB,Token(then,then)))), Node(VP,List(Leaf(VB,Token(switch,switch)), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Node(NML,List(Node(PP,List(Leaf(IN,Token(before,before)), Node(NP,List(Leaf(NN,Token(attribute,attribute)))))))), Leaf(NN,Token(name,name)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(Otherwise,otherwise)))), Leaf(Comma,Token(,,,)), Node(NP,List(Leaf(PRP,Token(you,you)))), Node(VP,List(Leaf(VBP,Token(treat,treat)), Node(NP,List(Leaf(PRP,Token(it,it)))), Node(ADVP,List(Leaf(RB,Token(as,as)), Node(PP,List(Leaf(IN,Token(per,per)), Node(NP,List(Leaf(DT,Token(the,the)), Node(NML,List(Leaf(LDoubleQuote,Token(",")), Node(FRAG,List(Node(NP,List(Leaf(NN,Token(anything,anything)))), Node(ADVP,List(Leaf(RB,Token(else,else)))))), Leaf(RDoubleQuote,Token(",")))), Leaf(NN,Token(entry,entry)))), Node(ADVP,List(Leaf(RB,Token(below,below)))))))))), Leaf(Dot,Token(.,.))))))
not match_s

 -> If(Bool(the_current_end_tag_token_is_an_appropriate_end_tag_token),List(Switch(the_before_attribute_name_state)),List())

-- chara: U+0020 SPACE --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, you treat it as per the "anything else" entry below.
List((5,CHAIN5-["the current end tag token" in sentence 1]))
List((5,CHAIN5-["it" in sentence 2]))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)))), Node(VP,List(Leaf(VBZ,Token(is,be)), Node(NP,List(Leaf(DT,Token(an,a)), Leaf(JJ,Token(appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)))), Leaf(NN,Token(token,token)))))))))), Leaf(Comma,Token(,,,)), Node(ADVP,List(Leaf(RB,Token(then,then)))), Node(VP,List(Leaf(VB,Token(switch,switch)), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Node(NML,List(Node(PP,List(Leaf(IN,Token(before,before)), Node(NP,List(Leaf(NN,Token(attribute,attribute)))))))), Leaf(NN,Token(name,name)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(Otherwise,otherwise)))), Leaf(Comma,Token(,,,)), Node(NP,List(Leaf(PRP,Token(you,you)))), Node(VP,List(Leaf(VBP,Token(treat,treat)), Node(NP,List(Leaf(PRP,Token(it,it)))), Node(ADVP,List(Leaf(RB,Token(as,as)), Node(PP,List(Leaf(IN,Token(per,per)), Node(NP,List(Leaf(DT,Token(the,the)), Node(NML,List(Leaf(LDoubleQuote,Token(",")), Node(FRAG,List(Node(NP,List(Leaf(NN,Token(anything,anything)))), Node(ADVP,List(Leaf(RB,Token(else,else)))))), Leaf(RDoubleQuote,Token(",")))), Leaf(NN,Token(entry,entry)))), Node(ADVP,List(Leaf(RB,Token(below,below)))))))))), Leaf(Dot,Token(.,.))))))
not match_s

 -> If(Bool(the_current_end_tag_token_is_an_appropriate_end_tag_token),List(Switch(the_before_attribute_name_state)),List())

-- chara: U+002F SOLIDUS (/) --
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
List((4,CHAIN4-["the current end tag token" in sentence 1]))
List((4,CHAIN4-["it" in sentence 2]))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)))), Node(VP,List(Leaf(VBZ,Token(is,be)), Node(NP,List(Leaf(DT,Token(an,a)), Leaf(JJ,Token(appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)))), Leaf(NN,Token(token,token)))))))))), Leaf(Comma,Token(,,,)), Node(ADVP,List(Leaf(RB,Token(then,then)))), Node(VP,List(Leaf(VB,Token(switch,switch)), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Node(NML,List(Leaf(NN,Token(self,self)), Leaf(HYPH,Token(-,-)), Leaf(NN,Token(closing,closing)))), Leaf(NN,Token(start,start)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(Otherwise,otherwise)))), Leaf(Comma,Token(,,,)), Node(VP,List(Leaf(VB,Token(treat,treat)), Node(NP,List(Leaf(PRP,Token(it,it)))), Node(PP,List(Leaf(IN,Token(as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(per,per)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(LDoubleQuote,Token(",")), Leaf(NN,Token(anything,anything)), Leaf(NN,Token(else,else)), Leaf(RDoubleQuote,Token(",")))))))), Leaf(NN,Token(entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(below,below)))))), Leaf(Dot,Token(.,.))))))

 -> If(Bool(the_current_end_tag_token_is_an_appropriate_end_tag_token),List(Switch(the_self_-_closing_start_tag_state)),List(Treat(null)))

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
List((6,CHAIN6-["the current end tag token" in sentence 1, "the current tag token" in sentence 1]))
List((6,CHAIN6-["it" in sentence 2]))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)))), Node(VP,List(Leaf(VBZ,Token(is,be)), Node(NP,List(Leaf(DT,Token(an,a)), Leaf(JJ,Token(appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)))), Leaf(NN,Token(token,token)))))))))), Leaf(Comma,Token(,,,)), Node(ADVP,List(Leaf(RB,Token(then,then)))), Node(VP,List(Node(VP,List(Leaf(VB,Token(switch,switch)), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(NN,Token(data,datum)), Leaf(NN,Token(state,state)))))))), Leaf(CC,Token(and,and)), Node(VP,List(Leaf(VB,Token(emit,emit)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(Otherwise,otherwise)))), Leaf(Comma,Token(,,,)), Node(VP,List(Leaf(VB,Token(treat,treat)), Node(NP,List(Leaf(PRP,Token(it,it)))), Node(PP,List(Leaf(IN,Token(as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(per,per)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(LDoubleQuote,Token(",")), Leaf(NN,Token(anything,anything)), Leaf(NN,Token(else,else)), Leaf(RDoubleQuote,Token(",")))))))), Leaf(NN,Token(entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(below,below)))))), Leaf(Dot,Token(.,.))))))

 -> If(Bool(the_current_end_tag_token_is_an_appropriate_end_tag_token),List(Switch(the_data_state), Emit(the_current_tag_token)),List(Treat(null)))

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
List((5,CHAIN5-["the current input character" in sentence 1, "the character 's" in sentence 1]))
List((5,CHAIN5-["the current input character" in sentence 2]))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VBD,Token(Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(NN,Token(lowercase,lowercase)), Leaf(NN,Token(version,version)))), Node(PP,List(Leaf(IN,Token(of,of)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(input,input)), Leaf(NN,Token(character,character)))))))), Node(PRN,List(Leaf(LBracket,Token((,()), Node(S,List(Node(VP,List(Leaf(VB,Token(add,add)), Node(NP,List(Leaf(NNS,Token(0x0020,0x0020)))), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(NN,Token(character,character)), Leaf(POS,Token('s,'s)))), Leaf(NN,Token(code,code)), Leaf(NN,Token(point,point)))))))))), Leaf(RBracket,Token(),))))), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)), Leaf(POS,Token('s,'s)))), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(name,name)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Append,append)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(input,input)), Leaf(NN,Token(character,character)))), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(temporary,temporary)), Leaf(NN,Token(buffer,buffer)))))))), Leaf(Dot,Token(.,.))))))

 -> Append(the_lowercase_version_of_the_current_input_character,the_current_tag_token_'s_tag_name)
 -> Append(the_current_input_character,the_temporary_buffer)

-- chara: ASCII lower alpha --
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
List((6,CHAIN6-["the current input character" in sentence 1]))
List((6,CHAIN6-["the current input character" in sentence 2]))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Append,append)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(input,input)), Leaf(NN,Token(character,character)))), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)), Leaf(POS,Token('s,'s)))), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(name,name)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Append,append)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(current,current)), Leaf(NN,Token(input,input)), Leaf(NN,Token(character,character)))), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(temporary,temporary)), Leaf(NN,Token(buffer,buffer)))))))), Leaf(Dot,Token(.,.))))))

 -> Append(the_current_input_character,the_current_tag_token_'s_tag_name)
 -> Append(the_current_input_character,the_temporary_buffer)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the RCDATA state.
List()
List()
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(a,a)), Node(NML,List(Node(NML,List(Leaf(NNP,Token(U,U)), Leaf(NNP,Token(+003,+003)), Leaf(NNP,Token(C,c)), Leaf(NNP,Token(LESS,less)))), Leaf(HYPH,Token(-,-)), Node(NML,List(Leaf(NNP,Token(THAN,than)), Leaf(NNP,Token(SIGN,SIGN)))))), Leaf(NN,Token(character,character)), Leaf(NN,Token(token,token)))), Leaf(Comma,Token(,,,)), Node(NP,List(Leaf(DT,Token(a,a)), Node(NML,List(Leaf(NNP,Token(U,U)), Leaf(NNP,Token(+002,+002)), Leaf(NNP,Token(F,F)), Leaf(NNP,Token(SOLIDUS,SOLIDUS)))), Leaf(NN,Token(character,character)), Leaf(NN,Token(token,token)))), Leaf(Comma,Token(,,,)), Leaf(CC,Token(and,and)), Node(NP,List(Node(NP,List(Leaf(DT,Token(a,a)), Leaf(NN,Token(character,character)), Leaf(NN,Token(token,token)))), Node(PP,List(Leaf(IN,Token(for,for)), Node(NP,List(Node(NP,List(Leaf(DT,Token(each,each)))), Node(PP,List(Leaf(IN,Token(of,of)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(NNS,Token(characters,character)))))))))))))), Node(PP,List(Leaf(IN,Token(in,in)), Node(NP,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(temporary,temporary)), Leaf(NN,Token(buffer,buffer)))), Leaf(LBracket,Token((,()), Node(PP,List(Leaf(IN,Token(in,in)), Node(NP,List(Node(NP,List(Leaf(DT,Token(the,the)), Leaf(NN,Token(order,order)))), Node(SBAR,List(Node(S,List(Node(NP,List(Leaf(PRP,Token(they,they)))), Node(VP,List(Leaf(VBD,Token(were,be)), Node(VP,List(Leaf(VBN,Token(added,add)), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(NN,Token(buffer,buffer)))))))))))))))))), Leaf(RBracket,Token(),))))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(in,in)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(NNP,Token(RCDATA,RCDATA)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))

 -> Emit(a_U_+003_C_LESS_-_THAN_SIGN_character_token_,_a_U_+002_F_SOLIDUS_character_token_,_and_a_character_token_for_each_of_the_characters_in_the_temporary_buffer_(_in_the_order_they_were_added_to_the_buffer_))
 -> Reconsume(the_RCDATA_state)

12 : RAWTEXT less-than sign state
-- chara: U+002F SOLIDUS (/) --
Set the temporary buffer to the empty string. Switch to the RAWTEXT end tag open state.
List()
List()
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Set,set)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(temporary,temporary)), Leaf(NN,Token(buffer,buffer)))), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(empty,empty)), Leaf(NN,Token(string,string)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Switch,switch)), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(RAWTEXT,rawtext)), Node(NML,List(Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)))), Leaf(JJ,Token(open,open)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))

 -> Set(the_temporary_buffer,the_empty_string)
 -> Switch(the_RAWTEXT_end_tag_open_state)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the RAWTEXT state.
List()
List()
Node(ROOT,List(Node(FRAG,List(Node(NP,List(Leaf(NNP,Token(Emit,emit)))), Node(NP,List(Leaf(DT,Token(a,a)), Leaf(NNP,Token(U,u)))), Node(NP,List(Leaf(CD,Token(+003,+003)))), Node(NP,List(Leaf(NNP,Token(C,c)), Leaf(NNP,Token(LESS,less)))), Leaf(Colon,Token(-,-)), Node(NP,List(Leaf(NNP,Token(THAN,than)), Leaf(NNP,Token(SIGN,SIGN)))), Node(NP,List(Leaf(NN,Token(character,character)))), Node(NP,List(Leaf(NN,Token(token,token)))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(in,in)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(RAWTEXT,rawtext)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))
error_root

 -> Reconsume(the_RAWTEXT_state)

13 : RAWTEXT end tag open state
-- chara: ASCII alpha --
Create a new end tag token, set its tag name to the empty string. Reconsume in the RAWTEXT end tag name state. 
List()
List()
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(Create,create)), Node(NP,List(Leaf(DT,Token(a,a)), Leaf(JJ,Token(new,new)), Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(token,token)))))), Leaf(Comma,Token(,,,)), Node(VP,List(Leaf(VB,Token(set,set)), Node(NP,List(Leaf(PRPD,Token(its,its)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(name,name)))), Node(PP,List(Leaf(IN,Token(to,to)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(empty,empty)), Leaf(NN,Token(string,string)))))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(in,in)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(NNP,Token(RAWTEXT,rawtext)), Leaf(NN,Token(end,end)), Leaf(NN,Token(tag,tag)), Leaf(NN,Token(name,name)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))

 -> Create(a_new_end_tag_token)
 -> Set(its_tag_name,the_empty_string)
 -> Reconsume(the_RAWTEXT_end_tag_name_state)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the RAWTEXT state.
List()
List()
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(a,a)), Node(NML,List(Node(NML,List(Leaf(NNP,Token(U,u)), Leaf(NNP,Token(+003,+003)), Leaf(NNP,Token(C,c)), Leaf(NNP,Token(LESS,less)))), Leaf(HYPH,Token(-,-)), Node(NML,List(Leaf(NNP,Token(THAN,than)), Leaf(NNP,Token(SIGN,SIGN)))))), Leaf(NN,Token(character,character)), Leaf(NN,Token(token,token)))), Leaf(CC,Token(and,and)), Node(NP,List(Leaf(DT,Token(a,a)), Node(NML,List(Leaf(NNP,Token(U,u)), Leaf(NNP,Token(+002,+002)), Leaf(NNP,Token(F,F)), Leaf(NNP,Token(SOLIDUS,SOLIDUS)))), Leaf(NN,Token(character,character)), Leaf(NN,Token(token,token)))))))), Leaf(Dot,Token(.,.))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(in,in)), Node(NP,List(Leaf(DT,Token(the,the)), Leaf(JJ,Token(RAWTEXT,rawtext)), Leaf(NN,Token(state,state)))))))), Leaf(Dot,Token(.,.))))))

 -> Emit(a_U_+003_C_LESS_-_THAN_SIGN_character_token_and_a_U_+002_F_SOLIDUS_character_token)
 -> Reconsume(the_RAWTEXT_state)


1 : Data_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0026 AMPERSAND (&amp;) --
Set the return state to the data state. Switch to the character reference state.
  | Set the return state to the Data_state. you Switch to the Character_reference_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Character_reference_state,Character_reference_state))))))))))))

 -> Set(the return state,the Data_state)
 -> Switch(Character_reference_state)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the tag open state.
  | you Switch to the Tag_open_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Tag_open_state,tag_open_state))))))))))))

 -> Switch(Tag_open_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Emit the current input character as a character token.
  | This is an unexpected_null_character parse error. you Emit the current input character as a character token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Emit(current input character as a character token,-1)

-- chara: EOF --
Emit an end-of-file token.
  | you Emit an end_of_file token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Emit the current input character as a character token.
  | you Emit the current input character as a character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Emit(current input character as a character token,-1)

2 : RCDATA_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0026 AMPERSAND (&amp;) --
Set the return state to the RCDATA state. Switch to the character reference state.
  | Set the return state to the RCDATA_state. you Switch to the Character_reference_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RCDATA_state,RCDATA_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Character_reference_state,Character_reference_state))))))))))))

 -> Set(the return state,the RCDATA_state)
 -> Switch(Character_reference_state)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the RCDATA less-than sign state.
  | you Switch to the RCDATA_less_than_sign_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RCDATA_less_than_sign_state,RCDATA_less_than_sign_state))))))))))))

 -> Switch(RCDATA_less_than_sign_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
Emit an end-of-file token.
  | you Emit an end_of_file token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Emit the current input character as a character token.
  | you Emit the current input character as a character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Emit(current input character as a character token,-1)

3 : RAWTEXT_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the RAWTEXT less-than sign state.
  | you Switch to the RAWTEXT_less_than_sign_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RAWTEXT_less_than_sign_state,rawtext_less_than_sign_state))))))))))))

 -> Switch(RAWTEXT_less_than_sign_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
Emit an end-of-file token.
  | you Emit an end_of_file token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Emit the current input character as a character token.
  | you Emit the current input character as a character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Emit(current input character as a character token,-1)

4 : Script_data_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the script data less-than sign state.
  | you Switch to the Script_data_less_than_sign_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_less_than_sign_state,script_data_less_than_sign_state))))))))))))

 -> Switch(Script_data_less_than_sign_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
Emit an end-of-file token.
  | you Emit an end_of_file token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Emit the current input character as a character token.
  | you Emit the current input character as a character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Emit(current input character as a character token,-1)

5 : PLAINTEXT_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
Emit an end-of-file token.
  | you Emit an end_of_file token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Emit the current input character as a character token.
  | you Emit the current input character as a character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Emit(current input character as a character token,-1)

6 : Tag_open_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0021 EXCLAMATION MARK (!) --
Switch to the markup declaration open state.
  | you Switch to the Markup_declaration_open_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Markup_declaration_open_state,Markup_declaration_open_state))))))))))))

 -> Switch(Markup_declaration_open_state)

-- chara: U+002F SOLIDUS (/) --
Switch to the end tag open state.
  | you Switch to the End_tag_open_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,End_tag_open_state,end_tag_open_state))))))))))))

 -> Switch(End_tag_open_state)

-- chara: ASCII alpha --
Create a new start tag token and set its tag name to the empty string. Reconsume in the tag name state. 
  | Create a new start tag token and set its tag name to the empty string. you Reconsume in the Tag_name_state. 
List(List((1,CHAIN1-["a new start tag token" in sentence 1, "its" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(1,a,a)), Leaf(JJ,Token(1,new,new)), Leaf(NN,Token(1,start,start)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(1,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,set,set)), Node(NP,List(Leaf(PRPD,Token(1,its,its)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Tag_name_state,tag_name_state))))))))))))

 -> Create(new start tag token,1)
 -> Set(its tag name,the empty string)
 -> Reconsume(Tag_name_state)

-- chara: U+003F QUESTION MARK (?) --
This is an unexpected-question-mark-instead-of-tag-name parse error. Create a comment token whose data is the empty string. Reconsume in the bogus comment state.
  | This is an unexpected_question_mark_instead_of_tag_name parse error. Create a comment token whose data is the empty string. you Reconsume in the Bogus_comment_state.
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_question_mark_instead_of_tag_name,unexpected_question_mark_instead_of_tag_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)))), Node(SBAR,List(Node(WHNP,List(Leaf(WPD,Token(-1,whose,whose)), Node(NML,List(Leaf(NNS,Token(-1,data,datum)))))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_comment_state,Bogus_comment_state))))))))))))

 -> Error(unexpected_question_mark_instead_of_tag_name parse error)
 -> Create(a comment token whose data is the empty string,-1)
 -> Reconsume(Bogus_comment_state)

-- chara: EOF --
This is an eof-before-tag-name parse error. Emit a U+003C LESS-THAN SIGN character token and an end-of-file token.
  | This is an eof_before_tag_name parse error. you Emit a U_003C LESS_THAN SIGN character token and an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_before_tag_name,eof_before_tag_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Error(eof_before_tag_name parse error)
 -> Emit(U_003C,-1)
 -> Emit(an end_of_file token,-1)

-- chara: Anything else --
This is an invalid-first-character-of-tag-name parse error. Emit a U+003C LESS-THAN SIGN character token. Reconsume in the data state.
  | This is an invalid_first_character_of_tag_name parse error. you Emit a U_003C LESS_THAN SIGN character token. you Reconsume in the Data_state.
List(List(), List((5,CHAIN5-["you" in sentence 2])), List((5,CHAIN5-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,invalid_first_character_of_tag_name,invalid_first_character_of_tag_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))

 -> Error(invalid_first_character_of_tag_name parse error)
 -> Emit(U_003C,-1)
 -> Reconsume(Data_state)

7 : End_tag_open_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII alpha --
Create a new end tag token, set its tag name to the empty string. Reconsume in the tag name state. 
  | Create a new end tag token and set its tag name to the empty string. you Reconsume in the Tag_name_state. 
List(List((1,CHAIN1-["a new end tag token" in sentence 1, "its" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(1,a,a)), Leaf(JJ,Token(1,new,new)), Leaf(NN,Token(1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(1,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,set,set)), Node(NP,List(Leaf(PRPD,Token(1,its,its)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Tag_name_state,tag_name_state))))))))))))

 -> Create(new end tag token,1)
 -> Set(its tag name,the empty string)
 -> Reconsume(Tag_name_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is a missing-end-tag-name parse error. Switch to the data state.
  | This is a missing_end_tag_name parse error. you Switch to the Data_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_end_tag_name,missing_end_tag_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))

 -> Error(missing_end_tag_name parse error)
 -> Switch(Data_state)

-- chara: EOF --
This is an eof-before-tag-name parse error. Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token and an end-of-file token. 
  | This is an eof_before_tag_name parse error. you Emit a U_003C LESS_THAN SIGN character token, a U_002F SOLIDUS character token and an end_of_file token. 
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_before_tag_name,eof_before_tag_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Error(eof_before_tag_name parse error)
 -> Emit(U_003C,-1)
 -> Emit(U_002F,-1)
 -> Emit(an end_of_file token,-1)

-- chara: Anything else --
This is an invalid-first-character-of-tag-name parse error. Create a comment token whose data is the empty string. Reconsume in the bogus comment state.
  | This is an invalid_first_character_of_tag_name parse error. Create a comment token whose data is the empty string. you Reconsume in the Bogus_comment_state.
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,invalid_first_character_of_tag_name,invalid_first_character_of_tag_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)))), Node(SBAR,List(Node(WHNP,List(Leaf(WPD,Token(-1,whose,whose)), Node(NML,List(Leaf(NNS,Token(-1,data,datum)))))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_comment_state,Bogus_comment_state))))))))))))

 -> Error(invalid_first_character_of_tag_name parse error)
 -> Create(a comment token whose data is the empty string,-1)
 -> Reconsume(Bogus_comment_state)

8 : Tag_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+000A LINE FEED (LF) --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+000C FORM FEED (FF) --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+0020 SPACE --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+002F SOLIDUS (/) --
Switch to the self-closing start tag state.
  | you Switch to the Self_closing_start_tag_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Self_closing_start_tag_state,self_closing_start_tag_state))))))))))))

 -> Switch(Self_closing_start_tag_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the current tag token.
  | you Switch to the Data_state. you Emit the current tag token.
List(List((5,CHAIN5-["you" in sentence 1])), List((5,CHAIN5-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(current tag token,-1)

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name.
  | you Append the lowercase version of the current input character (you add 0x0020 to the character's code point) to the current tag token's tag name.
List(List((6,CHAIN6-["you" in sentence 1, "you" in sentence 1]), (7,CHAIN7-["the current input character" in sentence 1, "the character 's" in sentence 1])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))

 -> Append(the lowercase version of the current input character,the current tag token 's tag name)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current tag token's tag name.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current tag token's tag name.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current tag token 's tag name)

-- chara: EOF --
This is an eof-in-tag parse error. Emit an end-of-file token.
  | This is an eof_in_tag parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(VB,Token(-1,eof_in_tag,eof_in_tag)), Node(NML,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,parse,parse)))))))), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_tag parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the current tag token's tag name.
  | you Append the current input character to the current tag token's tag name.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))

 -> Append(current input character,the current tag token 's tag name)

9 : RCDATA_less_than_sign_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002F SOLIDUS (/) --
Set the temporary buffer to the empty string. Switch to the RCDATA end tag open state.
  | Set the temporary buffer to the empty string. you Switch to the RCDATA_end_tag_open_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RCDATA_end_tag_open_state,RCDATA_end_tag_open_state))))))))))))

 -> Set(the temporary buffer,the empty string)
 -> Switch(RCDATA_end_tag_open_state)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the RCDATA state.
  | you Emit a U_003C LESS_THAN SIGN character token. you Reconsume in the RCDATA_state.
List(List((3,CHAIN3-["you" in sentence 1])), List((3,CHAIN3-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RCDATA_state,RCDATA_state))))))))))))

 -> Emit(U_003C,-1)
 -> Reconsume(RCDATA_state)

10 : RCDATA_end_tag_open_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII alpha --
Create a new end tag token, set its tag name to the empty string. Reconsume in the RCDATA end tag name state. 
  | Create a new end tag token and set its tag name to the empty string. you Reconsume in the RCDATA_end_tag_name_state. 
List(List((1,CHAIN1-["a new end tag token" in sentence 1, "its" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(1,a,a)), Leaf(JJ,Token(1,new,new)), Leaf(NN,Token(1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(1,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,set,set)), Node(NP,List(Leaf(PRPD,Token(1,its,its)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RCDATA_end_tag_name_state,RCDATA_end_tag_name_state))))))))))))

 -> Create(new end tag token,1)
 -> Set(its tag name,the empty string)
 -> Reconsume(RCDATA_end_tag_name_state)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the RCDATA state.
  | you Emit a U_003C LESS_THAN SIGN character token and a U_002F SOLIDUS character token. you Reconsume in the RCDATA_state.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RCDATA_state,RCDATA_state))))))))))))

 -> Emit(U_003C,-1)
 -> Emit(a U_002F,-1)
 -> Reconsume(RCDATA_state)

11 : RCDATA_end_tag_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+000A LINE FEED (LF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+000C FORM FEED (FF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+0020 SPACE --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+002F SOLIDUS (/) --
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Self_closing_start_tag_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Self_closing_start_tag_state,self_closing_start_tag_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Self_closing_start_tag_state)),List(Treat()))

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Data_state and you emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
List(List((6,CHAIN6-["you" in sentence 1, "you" in sentence 1]), (8,CHAIN8-["the current end tag token" in sentence 1, "the current tag token" in sentence 1])), List((8,CHAIN8-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(8,tag,tag)))), Leaf(NN,Token(8,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(NNP,Token(-1,Data_state,data_state)))))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,emit,emit)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(8,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Data_state), Emit(current tag token,8)),List(Treat()))

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
  | you Append the lowercase version of the current input character (you add 0x0020 to the character's code point) to the current tag token's tag name. you Append the current input character to the temporary buffer.
List(List((7,CHAIN7-["the current input character" in sentence 1, "the character 's" in sentence 1]), (14,CHAIN14-["you" in sentence 1, "you" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2]), (14,CHAIN14-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))

 -> Append(the lowercase version of the current input character,the current tag token 's tag name)
 -> Append(current input character,the temporary buffer)

-- chara: ASCII lower alpha --
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
  | you Append the current input character to the current tag token's tag name. you Append the current input character to the temporary buffer.
List(List((7,CHAIN7-["the current input character" in sentence 1]), (9,CHAIN9-["you" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2]), (9,CHAIN9-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))

 -> Append(current input character,the current tag token 's tag name)
 -> Append(current input character,the temporary buffer)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the RCDATA state.
  | you Emit a U_003C LESS_THAN SIGN character token, a U_002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were you added to the buffer). you Reconsume in the RCDATA_state.
List(List((10,CHAIN10-["the temporary buffer" in sentence 1, "the buffer" in sentence 1]), (12,CHAIN12-["you" in sentence 1, "you" in sentence 1])), List((12,CHAIN12-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,each,each)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(NNS,Token(-1,characters,character)))), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(10,temporary,temporary)), Leaf(NN,Token(10,buffer,buffer))))))))))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RCDATA_state,RCDATA_state))))))))))))

 -> Emit(U_003C,-1)
 -> Emit(U_002F,-1)
 -> Emit(a character token for each of the characters in the temporary buffer,-1)
 -> Reconsume(RCDATA_state)

12 : RAWTEXT_less_than_sign_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002F SOLIDUS (/) --
Set the temporary buffer to the empty string. Switch to the RAWTEXT end tag open state.
  | Set the temporary buffer to the empty string. you Switch to the RAWTEXT_end_tag_open_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RAWTEXT_end_tag_open_state,rawtext_end_tag_open_state))))))))))))

 -> Set(the temporary buffer,the empty string)
 -> Switch(RAWTEXT_end_tag_open_state)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the RAWTEXT state.
  | you Emit a U_003C LESS_THAN SIGN character token. you Reconsume in the RAWTEXT_state.
List(List((3,CHAIN3-["you" in sentence 1])), List((3,CHAIN3-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RAWTEXT_state,rawtext_state))))))))))))

 -> Emit(U_003C,-1)
 -> Reconsume(RAWTEXT_state)

13 : RAWTEXT_end_tag_open_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII alpha --
Create a new end tag token, set its tag name to the empty string. Reconsume in the RAWTEXT end tag name state. 
  | Create a new end tag token and set its tag name to the empty string. you Reconsume in the RAWTEXT_end_tag_name_state. 
List(List((1,CHAIN1-["a new end tag token" in sentence 1, "its" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(1,a,a)), Leaf(JJ,Token(1,new,new)), Leaf(NN,Token(1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(1,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,set,set)), Node(NP,List(Leaf(PRPD,Token(1,its,its)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RAWTEXT_end_tag_name_state,rawtext_end_tag_name_state))))))))))))

 -> Create(new end tag token,1)
 -> Set(its tag name,the empty string)
 -> Reconsume(RAWTEXT_end_tag_name_state)

-- chara: Anything else --
Emit a UP003C LESS-THAN SIGN character token and a UP002F SOLIDUS character token. Reconsume in the RAWTEXT state.
  | you Emit a UP003C LESS_THAN SIGN character token and a UP002F SOLIDUS character token. you Reconsume in the RAWTEXT_state.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,UP003C,up003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,UP002F,up002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RAWTEXT_state,rawtext_state))))))))))))

 -> Emit(UP003C LESS_THAN SIGN character token,-1)
 -> Emit(a UP002F SOLIDUS character token,-1)
 -> Reconsume(RAWTEXT_state)

14 : RAWTEXT_end_tag_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+000A LINE FEED (LF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+000C FORM FEED (FF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+0020 SPACE --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+002F SOLIDUS (/) --
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Self_closing_start_tag_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Self_closing_start_tag_state,self_closing_start_tag_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Self_closing_start_tag_state)),List(Treat()))

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Data_state and you emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
List(List((6,CHAIN6-["you" in sentence 1, "you" in sentence 1]), (8,CHAIN8-["the current end tag token" in sentence 1, "the current tag token" in sentence 1])), List((8,CHAIN8-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(8,tag,tag)))), Leaf(NN,Token(8,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(NNP,Token(-1,Data_state,data_state)))))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,emit,emit)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(8,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Data_state), Emit(current tag token,8)),List(Treat()))

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
  | you Append the lowercase version of the current input character (you add 0x0020 to the character's code point) to the current tag token's tag name. you Append the current input character to the temporary buffer.
List(List((7,CHAIN7-["the current input character" in sentence 1, "the character 's" in sentence 1]), (14,CHAIN14-["you" in sentence 1, "you" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2]), (14,CHAIN14-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))

 -> Append(the lowercase version of the current input character,the current tag token 's tag name)
 -> Append(current input character,the temporary buffer)

-- chara: ASCII lower alpha --
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
  | you Append the current input character to the current tag token's tag name. you Append the current input character to the temporary buffer.
List(List((7,CHAIN7-["the current input character" in sentence 1]), (9,CHAIN9-["you" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2]), (9,CHAIN9-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))

 -> Append(current input character,the current tag token 's tag name)
 -> Append(current input character,the temporary buffer)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the RAWTEXT state.
  | you Emit a U_003C LESS_THAN SIGN character token, a U_002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were you added to the buffer). you Reconsume in the RAWTEXT_state.
List(List((10,CHAIN10-["the temporary buffer" in sentence 1, "the buffer" in sentence 1]), (12,CHAIN12-["you" in sentence 1, "you" in sentence 1])), List((12,CHAIN12-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,each,each)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(NNS,Token(-1,characters,character)))), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(10,temporary,temporary)), Leaf(NN,Token(10,buffer,buffer))))))))))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,RAWTEXT_state,rawtext_state))))))))))))

 -> Emit(U_003C,-1)
 -> Emit(U_002F,-1)
 -> Emit(a character token for each of the characters in the temporary buffer,-1)
 -> Reconsume(RAWTEXT_state)

15 : Script_data_less_than_sign_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002F SOLIDUS (/) --
Set the temporary buffer to the empty string. Switch to the script data end tag open state.
  | Set the temporary buffer to the empty string. you Switch to the Script_data_end_tag_open_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_end_tag_open_state,script_data_end_tag_open_state))))))))))))

 -> Set(the temporary buffer,the empty string)
 -> Switch(Script_data_end_tag_open_state)

-- chara: U+0021 EXCLAMATION MARK (!) --
Switch to the script data escape start state. Emit a U+003C LESS-THAN SIGN character token and a U+0021 EXCLAMATION MARK character token.
  | you Switch to the Script_data_escape_start_state. you Emit a U_003C LESS_THAN SIGN character token and a U_0021 EXCLAMATION MARK character token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escape_start_state,script_data_escape_start_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_0021,u_0021)), Leaf(NNP,Token(-1,EXCLAMATION,EXCLAMATION)))), Leaf(NNP,Token(-1,MARK,MARK)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Switch(Script_data_escape_start_state)
 -> Emit(U_003C,-1)
 -> Emit(a U_0021,-1)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data state.
  | you Emit a U_003C LESS_THAN SIGN character token. you Reconsume in the Script_data_state.
List(List((3,CHAIN3-["you" in sentence 1])), List((3,CHAIN3-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_state,script_data_state))))))))))))

 -> Emit(U_003C,-1)
 -> Reconsume(Script_data_state)

16 : Script_data_end_tag_open_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII alpha --
Create a new end tag token, set its tag name to the empty string. Reconsume in the script data end tag name state. 
  | Create a new end tag token and set its tag name to the empty string. you Reconsume in the Script_data_end_tag_name_state. 
List(List((1,CHAIN1-["a new end tag token" in sentence 1, "its" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(1,a,a)), Leaf(JJ,Token(1,new,new)), Leaf(NN,Token(1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(1,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,set,set)), Node(NP,List(Leaf(PRPD,Token(1,its,its)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_end_tag_name_state,script_data_end_tag_name_state))))))))))))

 -> Create(new end tag token,1)
 -> Set(its tag name,the empty string)
 -> Reconsume(Script_data_end_tag_name_state)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the script data state.
  | you Emit a U_003C LESS_THAN SIGN character token and a U_002F SOLIDUS character token. you Reconsume in the Script_data_state.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_state,script_data_state))))))))))))

 -> Emit(U_003C,-1)
 -> Emit(a U_002F,-1)
 -> Reconsume(Script_data_state)

17 : Script_data_end_tag_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+000A LINE FEED (LF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+000C FORM FEED (FF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+0020 SPACE --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+002F SOLIDUS (/) --
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Self_closing_start_tag_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Self_closing_start_tag_state,self_closing_start_tag_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Self_closing_start_tag_state)),List(Treat()))

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Data_state and you emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
List(List((6,CHAIN6-["you" in sentence 1, "you" in sentence 1]), (8,CHAIN8-["the current end tag token" in sentence 1, "the current tag token" in sentence 1])), List((8,CHAIN8-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(8,tag,tag)))), Leaf(NN,Token(8,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(NNP,Token(-1,Data_state,data_state)))))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,emit,emit)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(8,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Data_state), Emit(current tag token,8)),List(Treat()))

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
  | you Append the lowercase version of the current input character (you add 0x0020 to the character's code point) to the current tag token's tag name. you Append the current input character to the temporary buffer.
List(List((7,CHAIN7-["the current input character" in sentence 1, "the character 's" in sentence 1]), (14,CHAIN14-["you" in sentence 1, "you" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2]), (14,CHAIN14-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))

 -> Append(the lowercase version of the current input character,the current tag token 's tag name)
 -> Append(current input character,the temporary buffer)

-- chara: ASCII lower alpha --
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
  | you Append the current input character to the current tag token's tag name. you Append the current input character to the temporary buffer.
List(List((7,CHAIN7-["the current input character" in sentence 1]), (9,CHAIN9-["you" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2]), (9,CHAIN9-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))

 -> Append(current input character,the current tag token 's tag name)
 -> Append(current input character,the temporary buffer)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the script data state.
  | you Emit a U_003C LESS_THAN SIGN character token, a U_002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were you added to the buffer). you Reconsume in the Script_data_state.
List(List((10,CHAIN10-["the temporary buffer" in sentence 1, "the buffer" in sentence 1]), (12,CHAIN12-["you" in sentence 1, "you" in sentence 1])), List((12,CHAIN12-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,each,each)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(NNS,Token(-1,characters,character)))), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(10,temporary,temporary)), Leaf(NN,Token(10,buffer,buffer))))))))))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_state,script_data_state))))))))))))

 -> Emit(U_003C,-1)
 -> Emit(U_002F,-1)
 -> Emit(a character token for each of the characters in the temporary buffer,-1)
 -> Reconsume(Script_data_state)

18 : Script_data_escape_start_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the script data escape start dash state. Emit a U+002D HYPHEN-MINUS character token.
  | you Switch to the Script_data_escape_start_dash_state. you Emit a U_002D HYPHEN_MINUS character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escape_start_dash_state,script_data_escape_start_dash_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNP,Token(-1,HYPHEN_MINUS,hyphen_minus)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_escape_start_dash_state)
 -> Emit(U_002D,-1)

-- chara: Anything else --
Reconsume in the script data state.
  | you Reconsume in the Script_data_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_state,script_data_state))))))))))))

 -> Reconsume(Script_data_state)

19 : Script_data_escape_start_dash_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the script data escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
  | you Switch to the Script_data_escaped_dash_dash_state. you Emit a U_002D HYPHEN_MINUS character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_dash_dash_state,script_data_escaped_dash_dash_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNP,Token(-1,HYPHEN_MINUS,hyphen_minus)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_escaped_dash_dash_state)
 -> Emit(U_002D,-1)

-- chara: Anything else --
Reconsume in the script data state.
  | you Reconsume in the Script_data_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_state,script_data_state))))))))))))

 -> Reconsume(Script_data_state)

20 : Script_data_escaped_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the script data escaped dash state. Emit a U+002D HYPHEN-MINUS character token.
  | you Switch to the Script_data_escaped_dash_state. you Emit a U_002D HYPHEN_MINUS character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_dash_state,script_data_escaped_dash_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNP,Token(-1,HYPHEN_MINUS,hyphen_minus)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_escaped_dash_state)
 -> Emit(U_002D,-1)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the script data escaped less-than sign state.
  | you Switch to the Script_data_escaped_less_than_sign_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_less_than_sign_state,script_data_escaped_less_than_sign_state))))))))))))

 -> Switch(Script_data_escaped_less_than_sign_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
  | This is an eof_in_script_html_comment_like_text parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_script_html_comment_like_text,eof_in_script_html_comment_like_text)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_script_html_comment_like_text parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Emit the current input character as a character token.
  | you Emit the current input character as a character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Emit(current input character as a character token,-1)

21 : Script_data_escaped_dash_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the script data escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
  | you Switch to the Script_data_escaped_dash_dash_state. you Emit a U_002D HYPHEN_MINUS character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_dash_dash_state,script_data_escaped_dash_dash_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNP,Token(-1,HYPHEN_MINUS,hyphen_minus)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_escaped_dash_dash_state)
 -> Emit(U_002D,-1)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the script data escaped less-than sign state.
  | you Switch to the Script_data_escaped_less_than_sign_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_less_than_sign_state,script_data_escaped_less_than_sign_state))))))))))))

 -> Switch(Script_data_escaped_less_than_sign_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Switch to the script data escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Switch to the Script_data_escaped_state. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List((6,CHAIN6-["you" in sentence 2])), List((6,CHAIN6-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Switch(Script_data_escaped_state)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
  | This is an eof_in_script_html_comment_like_text parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_script_html_comment_like_text,eof_in_script_html_comment_like_text)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_script_html_comment_like_text parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Switch to the script data escaped state. Emit the current input character as a character token.
  | you Switch to the Script_data_escaped_state. you Emit the current input character as a character token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Switch(Script_data_escaped_state)
 -> Emit(current input character as a character token,-1)

22 : Script_data_escaped_dash_dash_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Emit a U+002D HYPHEN-MINUS character token.
  | you Emit a U_002D HYPHEN_MINUS character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNP,Token(-1,HYPHEN_MINUS,hyphen_minus)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(U_002D,-1)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the script data escaped less-than sign state.
  | you Switch to the Script_data_escaped_less_than_sign_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_less_than_sign_state,script_data_escaped_less_than_sign_state))))))))))))

 -> Switch(Script_data_escaped_less_than_sign_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the script data state. Emit a U+003E GREATER-THAN SIGN character token.
  | you Switch to the Script_data_state. you Emit a U_003E GREATER_THAN SIGN character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_state,script_data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003E,u_003e)), Leaf(NNP,Token(-1,GREATER_THAN,GREATER_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_state)
 -> Emit(U_003E,-1)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Switch to the script data escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Switch to the Script_data_escaped_state. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List((6,CHAIN6-["you" in sentence 2])), List((6,CHAIN6-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Switch(Script_data_escaped_state)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
  | This is an eof_in_script_html_comment_like_text parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_script_html_comment_like_text,eof_in_script_html_comment_like_text)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_script_html_comment_like_text parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Switch to the script data escaped state. Emit the current input character as a character token.
  | you Switch to the Script_data_escaped_state. you Emit the current input character as a character token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Switch(Script_data_escaped_state)
 -> Emit(current input character as a character token,-1)

23 : Script_data_escaped_less_than_sign_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002F SOLIDUS (/) --
Set the temporary buffer to the empty string. Switch to the script data escaped end tag open state.
  | Set the temporary buffer to the empty string. you Switch to the Script_data_escaped_end_tag_open_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_end_tag_open_state,script_data_escaped_end_tag_open_state))))))))))))

 -> Set(the temporary buffer,the empty string)
 -> Switch(Script_data_escaped_end_tag_open_state)

-- chara: ASCII alpha --
Set the temporary buffer to the empty string. Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data double escape start state.
  | Set the temporary buffer to the empty string. you Emit a U_003C LESS_THAN SIGN character token. you Reconsume in the Script_data_double_escape_start_state.
List(List(), List((4,CHAIN4-["you" in sentence 2])), List((4,CHAIN4-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escape_start_state,script_data_double_escape_start_state))))))))))))

 -> Set(the temporary buffer,the empty string)
 -> Emit(U_003C,-1)
 -> Reconsume(Script_data_double_escape_start_state)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data escaped state.
  | you Emit a U_003C LESS_THAN SIGN character token. you Reconsume in the Script_data_escaped_state.
List(List((3,CHAIN3-["you" in sentence 1])), List((3,CHAIN3-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))

 -> Emit(U_003C,-1)
 -> Reconsume(Script_data_escaped_state)

24 : Script_data_escaped_end_tag_open_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII alpha --
Create a new end tag token, set its tag name to the empty string. Reconsume in the script data escaped end tag name state.
  | Create a new end tag token and set its tag name to the empty string. you Reconsume in the Script_data_escaped_end_tag_name_state.
List(List((1,CHAIN1-["a new end tag token" in sentence 1, "its" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(1,a,a)), Leaf(JJ,Token(1,new,new)), Leaf(NN,Token(1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(1,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,set,set)), Node(NP,List(Leaf(PRPD,Token(1,its,its)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_end_tag_name_state,script_data_escaped_end_tag_name_state))))))))))))

 -> Create(new end tag token,1)
 -> Set(its tag name,the empty string)
 -> Reconsume(Script_data_escaped_end_tag_name_state)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the script data escaped state.
  | you Emit a U_003C LESS_THAN SIGN character token and a U_002F SOLIDUS character token. you Reconsume in the Script_data_escaped_state.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))

 -> Emit(U_003C,-1)
 -> Emit(a U_002F,-1)
 -> Reconsume(Script_data_escaped_state)

25 : Script_data_escaped_end_tag_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+000A LINE FEED (LF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+000C FORM FEED (FF) --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+0020 SPACE --
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Before_attribute_name_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat()))

-- chara: U+002F SOLIDUS (/) --
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Self_closing_start_tag_state. Otherwise, treat it as per the "anything else" entry below.
List(List((5,CHAIN5-["the current end tag token" in sentence 1])), List((5,CHAIN5-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,tag,tag)))), Leaf(NN,Token(-1,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Self_closing_start_tag_state,self_closing_start_tag_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(5,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Self_closing_start_tag_state)),List(Treat()))

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
  | If the current end tag token is an appropriate end tag token, then you switch to the Data_state and you emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
List(List((6,CHAIN6-["you" in sentence 1, "you" in sentence 1]), (8,CHAIN8-["the current end tag token" in sentence 1, "the current tag token" in sentence 1])), List((8,CHAIN8-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,appropriate,appropriate)), Node(NML,List(Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(8,tag,tag)))), Leaf(NN,Token(8,token,token)))))))))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(NNP,Token(-1,Data_state,data_state)))))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,emit,emit)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,treat,treat)), Node(NP,List(Leaf(PRP,Token(8,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Data_state), Emit(current tag token,8)),List(Treat()))

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
  | you Append the lowercase version of the current input character (you add 0x0020 to the character's code point) to the current tag token's tag name. you Append the current input character to the temporary buffer.
List(List((7,CHAIN7-["the current input character" in sentence 1, "the character 's" in sentence 1]), (14,CHAIN14-["you" in sentence 1, "you" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2]), (14,CHAIN14-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))

 -> Append(the lowercase version of the current input character,the current tag token 's tag name)
 -> Append(current input character,the temporary buffer)

-- chara: ASCII lower alpha --
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
  | you Append the current input character to the current tag token's tag name. you Append the current input character to the temporary buffer.
List(List((7,CHAIN7-["the current input character" in sentence 1]), (9,CHAIN9-["you" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2]), (9,CHAIN9-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,name,name))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))

 -> Append(current input character,the current tag token 's tag name)
 -> Append(current input character,the temporary buffer)

-- chara: Anything else --
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer  (in the order they were added to the buffer). Reconsume in the script data escaped state.
  | you Emit a U_003C LESS_THAN SIGN character token, a U_002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer  (in the order they were you added to the buffer). you Reconsume in the Script_data_escaped_state.
List(List((10,CHAIN10-["the temporary buffer" in sentence 1, "the buffer" in sentence 1]), (12,CHAIN12-["you" in sentence 1, "you" in sentence 1])), List((12,CHAIN12-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token)))), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,each,each)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(NNS,Token(-1,characters,character)))), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(10,temporary,temporary)), Leaf(NN,Token(10,buffer,buffer))))))))))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))

 -> Emit(U_003C,-1)
 -> Emit(U_002F,-1)
 -> Emit(a character token for each of the characters in the temporary buffer,-1)
 -> Reconsume(Script_data_escaped_state)

26 : Script_data_double_escape_start_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
If the temporary buffer is the string "script", then switch to the script data double escaped state. Otherwise, switch to the script data escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_double_escaped_state. Otherwise, you switch to the Script_data_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+000A LINE FEED (LF) --
If the temporary buffer is the string "script", then switch to the script data double escaped state. Otherwise, switch to the script data escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_double_escaped_state. Otherwise, you switch to the Script_data_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+000C FORM FEED (FF) --
If the temporary buffer is the string "script", then switch to the script data double escaped state. Otherwise, switch to the script data escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_double_escaped_state. Otherwise, you switch to the Script_data_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+0020 SPACE --
If the temporary buffer is the string "script", then switch to the script data double escaped state. Otherwise, switch to the script data escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_double_escaped_state. Otherwise, you switch to the Script_data_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+002F SOLIDUS (/) --
If the temporary buffer is the string "script", then switch to the script data double escaped state. Otherwise, switch to the script data escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_double_escaped_state. Otherwise, you switch to the Script_data_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
If the temporary buffer is the string "script", then switch to the script data double escaped state. Otherwise, switch to the script data escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_double_escaped_state. Otherwise, you switch to the Script_data_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1)))

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the temporary buffer. Emit the current input character as a character token.
  | you Append the lowercase version of the current input character (you add 0x0020 to the character's code point) to the temporary buffer. you Emit the current input character as a character token.
List(List((6,CHAIN6-["the current input character" in sentence 1, "the character 's" in sentence 1]), (12,CHAIN12-["you" in sentence 1, "you" in sentence 1])), List((6,CHAIN6-["the current input character" in sentence 2]), (12,CHAIN12-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(6,current,current)), Leaf(NN,Token(6,input,input)), Leaf(NN,Token(6,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(6,the,the)), Leaf(JJ,Token(6,current,current)), Leaf(NN,Token(6,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Append(the lowercase version of the current input character,the temporary buffer)
 -> Emit(current input character as a character token,6)

-- chara: ASCII lower alpha --
Append the current input character to the temporary buffer. Emit the current input character as a character token.
  | you Append the current input character to the temporary buffer. you Emit the current input character as a character token.
List(List((5,CHAIN5-["the current input character" in sentence 1]), (7,CHAIN7-["you" in sentence 1])), List((5,CHAIN5-["the current input character" in sentence 2]), (7,CHAIN7-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(5,input,input)), Leaf(NN,Token(5,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(5,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(5,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Append(current input character,the temporary buffer)
 -> Emit(current input character as a character token,5)

-- chara: Anything else --
Reconsume in the script data escaped state.
  | you Reconsume in the Script_data_escaped_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))

 -> Reconsume(Script_data_escaped_state)

27 : Script_data_double_escaped_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the script data double escaped dash state. Emit a U+002D HYPHEN-MINUS character token.
  | you Switch to the Script_data_double_escaped_dash_state. you Emit a U_002D HYPHEN_MINUS character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_dash_state,script_data_double_escaped_dash_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNP,Token(-1,HYPHEN_MINUS,hyphen_minus)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_double_escaped_dash_state)
 -> Emit(U_002D,-1)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
  | you Switch to the Script_data_double_escaped_less_than_sign_state. you Emit a U_003C LESS_THAN SIGN character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_less_than_sign_state,script_data_double_escaped_less_than_sign_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_double_escaped_less_than_sign_state)
 -> Emit(U_003C,-1)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
  | This is an eof_in_script_html_comment_like_text parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_script_html_comment_like_text,eof_in_script_html_comment_like_text)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_script_html_comment_like_text parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Emit the current input character as a character token.
  | you Emit the current input character as a character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Emit(current input character as a character token,-1)

28 : Script_data_double_escaped_dash_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the script data double escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
  | you Switch to the Script_data_double_escaped_dash_dash_state. you Emit a U_002D HYPHEN_MINUS character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_dash_dash_state,script_data_double_escaped_dash_dash_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNP,Token(-1,HYPHEN_MINUS,hyphen_minus)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_double_escaped_dash_dash_state)
 -> Emit(U_002D,-1)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
  | you Switch to the Script_data_double_escaped_less_than_sign_state. you Emit a U_003C LESS_THAN SIGN character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_less_than_sign_state,script_data_double_escaped_less_than_sign_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_double_escaped_less_than_sign_state)
 -> Emit(U_003C,-1)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Switch to the script data double escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Switch to the Script_data_double_escaped_state. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List((6,CHAIN6-["you" in sentence 2])), List((6,CHAIN6-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Switch(Script_data_double_escaped_state)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
  | This is an eof_in_script_html_comment_like_text parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_script_html_comment_like_text,eof_in_script_html_comment_like_text)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_script_html_comment_like_text parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Switch to the script data double escaped state. Emit the current input character as a character token.
  | you Switch to the Script_data_double_escaped_state. you Emit the current input character as a character token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Switch(Script_data_double_escaped_state)
 -> Emit(current input character as a character token,-1)

29 : Script_data_double_escaped_dash_dash_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Emit a U+002D HYPHEN-MINUS character token.
  | you Emit a U_002D HYPHEN_MINUS character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNP,Token(-1,HYPHEN_MINUS,hyphen_minus)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(U_002D,-1)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
  | you Switch to the Script_data_double_escaped_less_than_sign_state. you Emit a U_003C LESS_THAN SIGN character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_less_than_sign_state,script_data_double_escaped_less_than_sign_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003C,u_003c)), Leaf(NNP,Token(-1,LESS_THAN,LESS_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_double_escaped_less_than_sign_state)
 -> Emit(U_003C,-1)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the script data state. Emit a U+003E GREATER-THAN SIGN character token.
  | you Switch to the Script_data_state. you Emit a U_003E GREATER_THAN SIGN character token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_state,script_data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003E,u_003e)), Leaf(NNP,Token(-1,GREATER_THAN,GREATER_THAN)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Script_data_state)
 -> Emit(U_003E,-1)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Switch to the script data double escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
  | This is an unexpected_null_character parse error. you Switch to the Script_data_double_escaped_state. you Emit a U_FFFD REPLACEMENT CHARACTER character token.
List(List(), List((6,CHAIN6-["you" in sentence 2])), List((6,CHAIN6-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Leaf(NNP,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(unexpected_null_character parse error)
 -> Switch(Script_data_double_escaped_state)
 -> Emit(U_FFFD,-1)

-- chara: EOF --
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
  | This is an eof_in_script_html_comment_like_text parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_script_html_comment_like_text,eof_in_script_html_comment_like_text)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_script_html_comment_like_text parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Switch to the script data double escaped state. Emit the current input character as a character token.
  | you Switch to the Script_data_double_escaped_state. you Emit the current input character as a character token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Switch(Script_data_double_escaped_state)
 -> Emit(current input character as a character token,-1)

30 : Script_data_double_escaped_less_than_sign_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002F SOLIDUS (/) --
Set the temporary buffer to the empty string. Switch to the script data double escape end state. Emit a U+002F SOLIDUS character token.
  | Set the temporary buffer to the empty string. you Switch to the Script_data_double_escape_end_state. you Emit a U_002F SOLIDUS character token.
List(List(), List((6,CHAIN6-["you" in sentence 2])), List((6,CHAIN6-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escape_end_state,script_data_double_escape_end_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_002F,u_002f)), Leaf(NNP,Token(-1,SOLIDUS,SOLIDUS)))), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Set(the temporary buffer,the empty string)
 -> Switch(Script_data_double_escape_end_state)
 -> Emit(U_002F,-1)

-- chara: Anything else --
Reconsume in the script data double escaped state.
  | you Reconsume in the Script_data_double_escaped_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))

 -> Reconsume(Script_data_double_escaped_state)

31 : Script_data_double_escape_end_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
If the temporary buffer is the string "script", then switch to the script data escaped state. Otherwise, switch to the script data double escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_escaped_state. Otherwise, you switch to the Script_data_double_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+000A LINE FEED (LF) --
If the temporary buffer is the string "script", then switch to the script data escaped state. Otherwise, switch to the script data double escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_escaped_state. Otherwise, you switch to the Script_data_double_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+000C FORM FEED (FF) --
If the temporary buffer is the string "script", then switch to the script data escaped state. Otherwise, switch to the script data double escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_escaped_state. Otherwise, you switch to the Script_data_double_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+0020 SPACE --
If the temporary buffer is the string "script", then switch to the script data escaped state. Otherwise, switch to the script data double escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_escaped_state. Otherwise, you switch to the Script_data_double_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+002F SOLIDUS (/) --
If the temporary buffer is the string "script", then switch to the script data escaped state. Otherwise, switch to the script data double escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_escaped_state. Otherwise, you switch to the Script_data_double_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1)))

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
If the temporary buffer is the string "script", then switch to the script data escaped state. Otherwise, switch to the script data double escaped state. Emit the current input character as a character token.
  | If the temporary buffer is the string "script", then you switch to the Script_data_escaped_state. Otherwise, you switch to the Script_data_double_escaped_state. you Emit the current input character as a character token.
List(List((9,CHAIN9-["you" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,script,script)), Leaf(RDoubleQuote,Token(-1,",")))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_escaped_state,script_data_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1)))

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the temporary buffer. Emit the current input character as a character token.
  | you Append the lowercase version of the current input character (you add 0x0020 to the character's code point) to the temporary buffer. you Emit the current input character as a character token.
List(List((6,CHAIN6-["the current input character" in sentence 1, "the character 's" in sentence 1]), (12,CHAIN12-["you" in sentence 1, "you" in sentence 1])), List((6,CHAIN6-["the current input character" in sentence 2]), (12,CHAIN12-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(6,current,current)), Leaf(NN,Token(6,input,input)), Leaf(NN,Token(6,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(6,the,the)), Leaf(JJ,Token(6,current,current)), Leaf(NN,Token(6,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Append(the lowercase version of the current input character,the temporary buffer)
 -> Emit(current input character as a character token,6)

-- chara: ASCII lower alpha --
Append the current input character to the temporary buffer. Emit the current input character as a character token.
  | you Append the current input character to the temporary buffer. you Emit the current input character as a character token.
List(List((5,CHAIN5-["the current input character" in sentence 1]), (7,CHAIN7-["you" in sentence 1])), List((5,CHAIN5-["the current input character" in sentence 2]), (7,CHAIN7-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(5,input,input)), Leaf(NN,Token(5,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(5,the,the)), Leaf(JJ,Token(5,current,current)), Leaf(NN,Token(5,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Append(current input character,the temporary buffer)
 -> Emit(current input character as a character token,5)

-- chara: Anything else --
Reconsume in the script data double escaped state.
  | you Reconsume in the Script_data_double_escaped_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Script_data_double_escaped_state,script_data_double_escaped_state))))))))))))

 -> Reconsume(Script_data_double_escaped_state)

32 : Before_attribute_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000A LINE FEED (LF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000C FORM FEED (FF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0020 SPACE --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+002F SOLIDUS (/) --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: EOF --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: U+003D EQUALS SIGN (=) --
This is an unexpected-equals-sign-before-attribute-name parse error. Start a new attribute in the current tag token. Set that attribute's name to the current input character, and its value to the empty string. Switch to the attribute name state.
  | This is an unexpected_equals_sign_before_attribute_name parse error. Start a new attribute in the current tag token and Set that attribute's name to the current input character, and its value to the empty string. you Switch to the Attribute_name_state.
List(List(), List((9,CHAIN9-["a new attribute" in sentence 2, "that attribute 's" in sentence 2, "its" in sentence 2])), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_equals_sign_before_attribute_name,unexpected_equals_sign_before_attribute_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Start,start)), Node(NP,List(Leaf(DT,Token(9,a,a)), Leaf(JJ,Token(9,new,new)), Leaf(NN,Token(9,attribute,attribute)))), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Node(NP,List(Node(NP,List(Leaf(DT,Token(9,that,that)), Leaf(NN,Token(9,attribute,attribute)), Leaf(POS,Token(9,'s,'s)))), Leaf(NN,Token(-1,name,name)))), Leaf(TO,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Node(NML,List(Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)))), Leaf(NN,Token(-1,character,character)))))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(NP,List(Node(NP,List(Leaf(PRPD,Token(9,its,its)), Leaf(NN,Token(-1,value,value)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Attribute_name_state,attribute_name_state))))))))))))

 -> Error(unexpected_equals_sign_before_attribute_name parse error)
 -> Start()
 -> Set(that attribute 's name,the current input character)
 -> Set(its value,the empty string)
 -> Switch(Attribute_name_state)

-- chara: Anything else --
Start a new attribute in the current tag token. Set that attribute name and value to the empty string. Reconsume in the attribute name state.
  | Start a new attribute in the current tag token and Set that attribute's name and value to the empty string. you Reconsume in the Attribute_name_state.
List(List((3,CHAIN3-["a new attribute" in sentence 1, "that attribute 's" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Start,start)), Node(NP,List(Leaf(DT,Token(3,a,a)), Leaf(JJ,Token(3,new,new)), Leaf(NN,Token(3,attribute,attribute)))), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(3,that,that)), Leaf(NN,Token(3,attribute,attribute)), Leaf(POS,Token(3,'s,'s)))), Leaf(NN,Token(-1,name,name)), Leaf(CC,Token(-1,and,and)), Leaf(NN,Token(-1,value,value)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Attribute_name_state,attribute_name_state))))))))))))

 -> Start()
 -> Set(that attribute 's name and value,the empty string)
 -> Reconsume(Attribute_name_state)

33 : Attribute_name_state
Consume the next input character:When the user agent leaves the attribute name state (and before emitting the tag token, if appropriate), the complete attribute's name must be compared to the other attributes on the same token; if there is already an attribute on the token with the exact same name, then this is a duplicate-attribute parse error and the new attribute must be removed from the token.If an attribute is so removed from a token, it, and the value that gets associated with it, if any, are never subsequently used by the parser, and are therefore effectively discarded. Removing the attribute in this way does not change its status as the "current attribute" for the purposes of the tokenizer, however.
  | Consume the next input character:When the user agent leaves the Attribute_name_state (and before you emitting the tag token, if appropriate), the complete attribute's name must be compared to the other attributes on the same token; if there is already an attribute on the token with the exact same name, then this is a duplicate_attribute parse error. the new attribute must be removed from the token.If an attribute is so removed from a token, it, and the value that gets associated with it, if any, are never subsequently used by the parser, and are therefore effectively discarded. Removing the attribute in this way does not change its status as the "current attribute" for the purposes of the tokenizer, however.
List(List((8,CHAIN8-["the tag token" in sentence 1, "the same token" in sentence 1]), (11,CHAIN11-["the complete attribute 's name" in sentence 1, "the exact same name" in sentence 1]), (31,CHAIN31-["the complete attribute 's" in sentence 1])), List((22,CHAIN22-["an attribute" in sentence 2, "it" in sentence 2, "it" in sentence 2]), (31,CHAIN31-["the new attribute" in sentence 2])), List((26,CHAIN26-["this way" in sentence 3, "its" in sentence 3]), (31,CHAIN31-["the attribute in this way" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Leaf(Colon,Token(-1,:,:)), Node(SBAR,List(Node(SBAR,List(Node(WHADVP,List(Leaf(WRB,Token(-1,When,when)))), Node(S,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(NN,Token(-1,user,user)), Leaf(NN,Token(-1,agent,agent)))), Node(VP,List(Leaf(VB,Token(-1,leaves,leave)), Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(NNP,Token(-1,Attribute_name_state,attribute_name_state)))))))))), Leaf(LBracket,Token(-1,(,()), Leaf(CC,Token(-1,and,and)), Node(SBAR,List(Leaf(IN,Token(-1,before,before)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,emitting,emit)), Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(FRAG,List(Node(ADJP,List(Leaf(JJ,Token(-1,appropriate,appropriate)))))))))))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(31,complete,complete)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(31,'s,'s)))), Leaf(NN,Token(11,name,name)))), Node(VP,List(Leaf(MD,Token(-1,must,must)), Node(VP,List(Leaf(VB,Token(-1,be,be)), Node(VP,List(Leaf(VB,Token(-1,compared,compare)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(-1,other,other)), Leaf(NNS,Token(-1,attributes,attribute)))), Node(PP,List(Leaf(IN,Token(-1,on,on)), Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(11,same,same)), Leaf(NN,Token(-1,token,token)))))))))))))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(S,List(Node(NP,List(Leaf(EX,Token(-1,there,there)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(ADVP,List(Leaf(RB,Token(-1,already,already)))), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(NN,Token(-1,attribute,attribute)))), Node(PP,List(Leaf(IN,Token(-1,on,on)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(NN,Token(-1,token,token)))), Node(PP,List(Leaf(IN,Token(-1,with,with)), Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(11,exact,exact)), Leaf(JJ,Token(11,same,same)), Leaf(NN,Token(11,name,name)))))))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(NP,List(Leaf(DT,Token(-1,this,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,duplicate_attribute,duplicate_attribute)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(31,new,new)), Leaf(NN,Token(22,attribute,attribute)))), Node(VP,List(Leaf(MD,Token(-1,must,must)), Node(VP,List(Leaf(VB,Token(-1,be,be)), Node(VP,List(Leaf(VB,Token(-1,removed,remove)), Node(PP,List(Leaf(IN,Token(-1,from,from)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,token.If,token.If)))), Node(SBAR,List(Node(S,List(Node(NP,List(Leaf(DT,Token(22,an,a)), Leaf(NN,Token(22,attribute,attribute)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(ADVP,List(Leaf(RB,Token(-1,so,so)))), Node(VP,List(Leaf(VB,Token(-1,removed,remove)), Node(PP,List(Leaf(IN,Token(-1,from,from)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(PRP,Token(22,it,it)))))))))))))))))))))))))))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,value,value)))), Node(SBAR,List(Node(WHNP,List(Leaf(WDT,Token(-1,that,that)))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,gets,get)), Node(VP,List(Leaf(VB,Token(-1,associated,associate)), Node(PP,List(Leaf(IN,Token(-1,with,with)), Node(NP,List(Leaf(PRP,Token(22,it,it)))))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(FRAG,List(Leaf(DT,Token(-1,any,any)))))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(ADVP,List(Leaf(RB,Token(-1,never,never)))), Node(ADVP,List(Leaf(RB,Token(-1,subsequently,subsequently)))), Node(VP,List(Leaf(VB,Token(-1,used,use)), Node(PP,List(Leaf(IN,Token(-1,by,by)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,parser,parser)))))))))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(ADVP,List(Leaf(RB,Token(-1,therefore,therefore)))), Node(ADVP,List(Leaf(RB,Token(-1,effectively,effectively)))), Node(VP,List(Leaf(VB,Token(-1,discarded,discard))))))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Removing,remove)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,attribute,attribute)))), Node(PP,List(Leaf(IN,Token(31,in,in)), Node(NP,List(Leaf(DT,Token(31,this,this)), Leaf(NN,Token(31,way,way)))))))))))), Node(VP,List(Leaf(VB,Token(-1,does,do)), Leaf(RB,Token(-1,not,not)), Node(VP,List(Leaf(VB,Token(-1,change,change)), Node(NP,List(Leaf(PRPD,Token(26,its,its)), Leaf(NN,Token(-1,status,status)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(RDoubleQuote,Token(-1,",")))), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNS,Token(-1,purposes,purpose)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,tokenizer,tokenizer)))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,however,however))))))))))))
### not match_s : List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Leaf(Colon,Token(-1,:,:)), Node(SBAR,List(Node(SBAR,List(Node(WHADVP,List(Leaf(WRB,Token(-1,When,when)))), Node(S,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(NN,Token(-1,user,user)), Leaf(NN,Token(-1,agent,agent)))), Node(VP,List(Leaf(VB,Token(-1,leaves,leave)), Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(NNP,Token(-1,Attribute_name_state,attribute_name_state)))))))))), Leaf(LBracket,Token(-1,(,()), Leaf(CC,Token(-1,and,and)), Node(SBAR,List(Leaf(IN,Token(-1,before,before)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,emitting,emit)), Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(FRAG,List(Node(ADJP,List(Leaf(JJ,Token(-1,appropriate,appropriate)))))))))))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(31,complete,complete)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(31,'s,'s)))), Leaf(NN,Token(11,name,name)))), Node(VP,List(Leaf(MD,Token(-1,must,must)), Node(VP,List(Leaf(VB,Token(-1,be,be)), Node(VP,List(Leaf(VB,Token(-1,compared,compare)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(-1,other,other)), Leaf(NNS,Token(-1,attributes,attribute)))), Node(PP,List(Leaf(IN,Token(-1,on,on)), Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(11,same,same)), Leaf(NN,Token(-1,token,token)))))))))))))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(S,List(Node(NP,List(Leaf(EX,Token(-1,there,there)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(ADVP,List(Leaf(RB,Token(-1,already,already)))), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(NN,Token(-1,attribute,attribute)))), Node(PP,List(Leaf(IN,Token(-1,on,on)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(NN,Token(-1,token,token)))), Node(PP,List(Leaf(IN,Token(-1,with,with)), Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(11,exact,exact)), Leaf(JJ,Token(11,same,same)), Leaf(NN,Token(11,name,name)))))))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(NP,List(Leaf(DT,Token(-1,this,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,duplicate_attribute,duplicate_attribute)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error)))))))))
### not match_s : List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(31,new,new)), Leaf(NN,Token(22,attribute,attribute)))), Node(VP,List(Leaf(MD,Token(-1,must,must)), Node(VP,List(Leaf(VB,Token(-1,be,be)), Node(VP,List(Leaf(VB,Token(-1,removed,remove)), Node(PP,List(Leaf(IN,Token(-1,from,from)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,token.If,token.If)))), Node(SBAR,List(Node(S,List(Node(NP,List(Leaf(DT,Token(22,an,a)), Leaf(NN,Token(22,attribute,attribute)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(ADVP,List(Leaf(RB,Token(-1,so,so)))), Node(VP,List(Leaf(VB,Token(-1,removed,remove)), Node(PP,List(Leaf(IN,Token(-1,from,from)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,token,token)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(PRP,Token(22,it,it)))))))))))))))))))))))))))
### not match_s : List(Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,value,value)))), Node(SBAR,List(Node(WHNP,List(Leaf(WDT,Token(-1,that,that)))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,gets,get)), Node(VP,List(Leaf(VB,Token(-1,associated,associate)), Node(PP,List(Leaf(IN,Token(-1,with,with)), Node(NP,List(Leaf(PRP,Token(22,it,it)))))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(FRAG,List(Leaf(DT,Token(-1,any,any)))))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(ADVP,List(Leaf(RB,Token(-1,never,never)))), Node(ADVP,List(Leaf(RB,Token(-1,subsequently,subsequently)))), Node(VP,List(Leaf(VB,Token(-1,used,use)), Node(PP,List(Leaf(IN,Token(-1,by,by)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,parser,parser)))))))))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(ADVP,List(Leaf(RB,Token(-1,therefore,therefore)))), Node(ADVP,List(Leaf(RB,Token(-1,effectively,effectively)))), Node(VP,List(Leaf(VB,Token(-1,discarded,discard)))))))))
### not match_s : List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Removing,remove)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,attribute,attribute)))), Node(PP,List(Leaf(IN,Token(31,in,in)), Node(NP,List(Leaf(DT,Token(31,this,this)), Leaf(NN,Token(31,way,way)))))))))))), Node(VP,List(Leaf(VB,Token(-1,does,do)), Leaf(RB,Token(-1,not,not)), Node(VP,List(Leaf(VB,Token(-1,change,change)), Node(NP,List(Leaf(PRPD,Token(26,its,its)), Leaf(NN,Token(-1,status,status)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(RDoubleQuote,Token(-1,",")))), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNS,Token(-1,purposes,purpose)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,tokenizer,tokenizer)))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,however,however)))))))))


-- chara: U+0009 CHARACTER TABULATION (tab) --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: U+000A LINE FEED (LF) --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: U+000C FORM FEED (FF) --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: U+0020 SPACE --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: U+002F SOLIDUS (/) --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: EOF --
Reconsume in the after attribute name state.
  | you Reconsume in the After_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_name_state,after_attribute_name_state))))))))))))

 -> Reconsume(After_attribute_name_state)

-- chara: U+003D EQUALS SIGN (=) --
Switch to the before attribute value state.
  | you Switch to the Before_attribute_value_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_value_state,before_attribute_value_state))))))))))))

 -> Switch(Before_attribute_value_state)

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current attribute's name.
  | you Append the lowercase version of the current input character (you add 0x0020 to the character's code point) to the current attribute's name.
List(List((6,CHAIN6-["you" in sentence 1, "you" in sentence 1]), (7,CHAIN7-["the current input character" in sentence 1, "the character 's" in sentence 1])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,name,name))))))))))))

 -> Append(the lowercase version of the current input character,the current attribute 's name)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's name.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current attribute's name.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,name,name))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current attribute 's name)

-- chara: U+0022 QUOTATION MARK (") --
This is an unexpected-character-in-attribute-name parse error. Treat it as per the "anything else" entry below.
  | This is an unexpected_character_in_attribute_name parse error. Treat it as per the "anything else" entry below.
List(List((3,CHAIN3-["This" in sentence 1])), List((3,CHAIN3-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(3,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_character_in_attribute_name,unexpected_character_in_attribute_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Treat,treat)), Node(NP,List(Leaf(PRP,Token(3,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> Error(unexpected_character_in_attribute_name parse error)
 -> Treat()

-- chara: U+0027 APOSTROPHE (') --
This is an unexpected-character-in-attribute-name parse error. Treat it as per the "anything else" entry below.
  | This is an unexpected_character_in_attribute_name parse error. Treat it as per the "anything else" entry below.
List(List((3,CHAIN3-["This" in sentence 1])), List((3,CHAIN3-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(3,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_character_in_attribute_name,unexpected_character_in_attribute_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Treat,treat)), Node(NP,List(Leaf(PRP,Token(3,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> Error(unexpected_character_in_attribute_name parse error)
 -> Treat()

-- chara: U+003C LESS-THAN SIGN (&lt;) --
This is an unexpected-character-in-attribute-name parse error. Treat it as per the "anything else" entry below.
  | This is an unexpected_character_in_attribute_name parse error. Treat it as per the "anything else" entry below.
List(List((3,CHAIN3-["This" in sentence 1])), List((3,CHAIN3-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(3,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_character_in_attribute_name,unexpected_character_in_attribute_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Treat,treat)), Node(NP,List(Leaf(PRP,Token(3,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> Error(unexpected_character_in_attribute_name parse error)
 -> Treat()

-- chara: Anything else --
Append the current input character to the current attribute's name.
  | you Append the current input character to the current attribute's name.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,name,name))))))))))))

 -> Append(current input character,the current attribute 's name)

34 : After_attribute_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000A LINE FEED (LF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000C FORM FEED (FF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0020 SPACE --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+002F SOLIDUS (/) --
Switch to the self-closing start tag state.
  | you Switch to the Self_closing_start_tag_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Self_closing_start_tag_state,self_closing_start_tag_state))))))))))))

 -> Switch(Self_closing_start_tag_state)

-- chara: U+003D EQUALS SIGN (=) --
Switch to the before attribute value state.
  | you Switch to the Before_attribute_value_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_value_state,before_attribute_value_state))))))))))))

 -> Switch(Before_attribute_value_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the current tag token.
  | you Switch to the Data_state. you Emit the current tag token.
List(List((5,CHAIN5-["you" in sentence 1])), List((5,CHAIN5-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(current tag token,-1)

-- chara: EOF --
This is an eof-in-tag parse error. Emit an end-of-file token.
  | This is an eof_in_tag parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(VB,Token(-1,eof_in_tag,eof_in_tag)), Node(NML,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,parse,parse)))))))), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_tag parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Start a new attribute in the current tag token. Set that attribute name and value to the empty string. Reconsume in the attribute name state.
  | Start a new attribute in the current tag token and Set that attribute's name and value to the empty string. you Reconsume in the Attribute_name_state.
List(List((3,CHAIN3-["a new attribute" in sentence 1, "that attribute 's" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Start,start)), Node(NP,List(Leaf(DT,Token(3,a,a)), Leaf(JJ,Token(3,new,new)), Leaf(NN,Token(3,attribute,attribute)))), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token)))))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(3,that,that)), Leaf(NN,Token(3,attribute,attribute)), Leaf(POS,Token(3,'s,'s)))), Leaf(NN,Token(-1,name,name)), Leaf(CC,Token(-1,and,and)), Leaf(NN,Token(-1,value,value)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Attribute_name_state,attribute_name_state))))))))))))

 -> Start()
 -> Set(that attribute 's name and value,the empty string)
 -> Reconsume(Attribute_name_state)

35 : Before_attribute_value_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000A LINE FEED (LF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000C FORM FEED (FF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0020 SPACE --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0022 QUOTATION MARK (") --
Switch to the attribute value (double-quoted) state.
  | you Switch to the Attribute_value_double_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Attribute_value_double_quoted_state,attribute_value_double_quoted_state))))))))))))

 -> Switch(Attribute_value_double_quoted_state)

-- chara: U+0027 APOSTROPHE (') --
Switch to the attribute value (single-quoted) state.
  | you Switch to the Attribute_value_single_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Attribute_value_single_quoted_state,attribute_value_single_quoted_state))))))))))))

 -> Switch(Attribute_value_single_quoted_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is a missing-attribute-value parse error. Switch to the data state. Emit the current tag token.
  | This is a missing_attribute_value parse error. you Switch to the Data_state. you Emit the current tag token.
List(List(), List((8,CHAIN8-["you" in sentence 2])), List((8,CHAIN8-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_attribute_value,missing_attribute_value)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(missing_attribute_value parse error)
 -> Switch(Data_state)
 -> Emit(current tag token,-1)

-- chara: Anything else --
Reconsume in the attribute value (unquoted) state.
  | you Reconsume in the Attribute_value_unquoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Attribute_value_unquoted_state,attribute_value_unquoted_state))))))))))))

 -> Reconsume(Attribute_value_unquoted_state)

36 : Attribute_value_double_quoted_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0022 QUOTATION MARK (") --
Switch to the after attribute value (quoted) state.
  | you Switch to the After_attribute_value_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_value_quoted_state,after_attribute_value_quoted_state))))))))))))

 -> Switch(After_attribute_value_quoted_state)

-- chara: U+0026 AMPERSAND (&amp;) --
Set the return state to the attribute value (double-quoted) state. Switch to the character reference state.
  | Set the return state to the Attribute_value_double_quoted_state. you Switch to the Character_reference_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Attribute_value_double_quoted_state,attribute_value_double_quoted_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Character_reference_state,Character_reference_state))))))))))))

 -> Set(the return state,the Attribute_value_double_quoted_state)
 -> Switch(Character_reference_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current attribute's value.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,value,value))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current attribute 's value)

-- chara: EOF --
This is an eof-in-tag parse error. Emit an end-of-file token.
  | This is an eof_in_tag parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(VB,Token(-1,eof_in_tag,eof_in_tag)), Node(NML,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,parse,parse)))))))), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_tag parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the current attribute's value.
  | you Append the current input character to the current attribute's value.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,value,value))))))))))))

 -> Append(current input character,the current attribute 's value)

37 : Attribute_value_single_quoted_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0027 APOSTROPHE (') --
Switch to the after attribute value (quoted) state.
  | you Switch to the After_attribute_value_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_attribute_value_quoted_state,after_attribute_value_quoted_state))))))))))))

 -> Switch(After_attribute_value_quoted_state)

-- chara: U+0026 AMPERSAND (&amp;) --
Set the return state to the attribute value (single-quoted) state. Switch to the character reference state.
  | Set the return state to the Attribute_value_single_quoted_state. you Switch to the Character_reference_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Attribute_value_single_quoted_state,attribute_value_single_quoted_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Character_reference_state,Character_reference_state))))))))))))

 -> Set(the return state,the Attribute_value_single_quoted_state)
 -> Switch(Character_reference_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current attribute's value.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,value,value))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current attribute 's value)

-- chara: EOF --
This is an eof-in-tag parse error. Emit an end-of-file token.
  | This is an eof_in_tag parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(VB,Token(-1,eof_in_tag,eof_in_tag)), Node(NML,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,parse,parse)))))))), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_tag parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the current attribute's value.
  | you Append the current input character to the current attribute's value.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,value,value))))))))))))

 -> Append(current input character,the current attribute 's value)

38 : Attribute_value_unquoted_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+000A LINE FEED (LF) --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+000C FORM FEED (FF) --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+0020 SPACE --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+0026 AMPERSAND (&amp;) --
Set the return state to the attribute value (unquoted) state. Switch to the character reference state.
  | Set the return state to the Attribute_value_unquoted_state. you Switch to the Character_reference_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Attribute_value_unquoted_state,attribute_value_unquoted_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Character_reference_state,Character_reference_state))))))))))))

 -> Set(the return state,the Attribute_value_unquoted_state)
 -> Switch(Character_reference_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the current tag token.
  | you Switch to the Data_state. you Emit the current tag token.
List(List((5,CHAIN5-["you" in sentence 1])), List((5,CHAIN5-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(current tag token,-1)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current attribute's value.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,value,value))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current attribute 's value)

-- chara: U+0022 QUOTATION MARK (") --
This is an unexpected-character-in-unquoted-attribute-value parse error. Treat it as per the "anything else" entry below.
  | This is an unexpected_character_in_unquoted_attribute_value parse error. Treat it as per the "anything else" entry below.
List(List((3,CHAIN3-["This" in sentence 1])), List((3,CHAIN3-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(3,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_character_in_unquoted_attribute_value,unexpected_character_in_unquoted_attribute_value)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Treat,treat)), Node(NP,List(Leaf(PRP,Token(3,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> Error(unexpected_character_in_unquoted_attribute_value parse error)
 -> Treat()

-- chara: U+0027 APOSTROPHE (') --
This is an unexpected-character-in-unquoted-attribute-value parse error. Treat it as per the "anything else" entry below.
  | This is an unexpected_character_in_unquoted_attribute_value parse error. Treat it as per the "anything else" entry below.
List(List((3,CHAIN3-["This" in sentence 1])), List((3,CHAIN3-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(3,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_character_in_unquoted_attribute_value,unexpected_character_in_unquoted_attribute_value)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Treat,treat)), Node(NP,List(Leaf(PRP,Token(3,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> Error(unexpected_character_in_unquoted_attribute_value parse error)
 -> Treat()

-- chara: U+003C LESS-THAN SIGN (&lt;) --
This is an unexpected-character-in-unquoted-attribute-value parse error. Treat it as per the "anything else" entry below.
  | This is an unexpected_character_in_unquoted_attribute_value parse error. Treat it as per the "anything else" entry below.
List(List((3,CHAIN3-["This" in sentence 1])), List((3,CHAIN3-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(3,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_character_in_unquoted_attribute_value,unexpected_character_in_unquoted_attribute_value)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Treat,treat)), Node(NP,List(Leaf(PRP,Token(3,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> Error(unexpected_character_in_unquoted_attribute_value parse error)
 -> Treat()

-- chara: U+003D EQUALS SIGN (=) --
This is an unexpected-character-in-unquoted-attribute-value parse error. Treat it as per the "anything else" entry below.
  | This is an unexpected_character_in_unquoted_attribute_value parse error. Treat it as per the "anything else" entry below.
List(List((3,CHAIN3-["This" in sentence 1])), List((3,CHAIN3-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(3,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_character_in_unquoted_attribute_value,unexpected_character_in_unquoted_attribute_value)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Treat,treat)), Node(NP,List(Leaf(PRP,Token(3,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> Error(unexpected_character_in_unquoted_attribute_value parse error)
 -> Treat()

-- chara: U+0060 GRAVE ACCENT (`) --
This is an unexpected-character-in-unquoted-attribute-value parse error. Treat it as per the "anything else" entry below.
  | This is an unexpected_character_in_unquoted_attribute_value parse error. Treat it as per the "anything else" entry below.
List(List((3,CHAIN3-["This" in sentence 1])), List((3,CHAIN3-["it" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(3,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_character_in_unquoted_attribute_value,unexpected_character_in_unquoted_attribute_value)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Treat,treat)), Node(NP,List(Leaf(PRP,Token(3,it,it)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,per,per)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,anything,anything)), Leaf(NN,Token(-1,else,else)), Leaf(RDoubleQuote,Token(-1,",")))))))), Leaf(NN,Token(-1,entry,entry)))))), Node(ADVP,List(Leaf(RB,Token(-1,below,below))))))))))

 -> Error(unexpected_character_in_unquoted_attribute_value parse error)
 -> Treat()

-- chara: EOF --
This is an eof-in-tag parse error. Emit an end-of-file token.
  | This is an eof_in_tag parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(VB,Token(-1,eof_in_tag,eof_in_tag)), Node(NML,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,parse,parse)))))))), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_tag parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the current attribute's value.
  | you Append the current input character to the current attribute's value.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,attribute,attribute)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,value,value))))))))))))

 -> Append(current input character,the current attribute 's value)

39 : After_attribute_value_quoted_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+000A LINE FEED (LF) --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+000C FORM FEED (FF) --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+0020 SPACE --
Switch to the before attribute name state.
  | you Switch to the Before_attribute_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Switch(Before_attribute_name_state)

-- chara: U+002F SOLIDUS (/) --
Switch to the self-closing start tag state.
  | you Switch to the Self_closing_start_tag_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Self_closing_start_tag_state,self_closing_start_tag_state))))))))))))

 -> Switch(Self_closing_start_tag_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the current tag token.
  | you Switch to the Data_state. you Emit the current tag token.
List(List((5,CHAIN5-["you" in sentence 1])), List((5,CHAIN5-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,tag,tag)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(current tag token,-1)

-- chara: EOF --
This is an eof-in-tag parse error. Emit an end-of-file token.
  | This is an eof_in_tag parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(VB,Token(-1,eof_in_tag,eof_in_tag)), Node(NML,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,parse,parse)))))))), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_tag parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is a missing-whitespace-between-attributes parse error. Reconsume in the before attribute name state. 
  | This is a missing_whitespace_between_attributes parse error. you Reconsume in the Before_attribute_name_state. 
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_whitespace_between_attributes,missing_whitespace_between_attributes)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Error(missing_whitespace_between_attributes parse error)
 -> Reconsume(Before_attribute_name_state)

40 : Self_closing_start_tag_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Set the self-closing flag of the current tag token. Switch to the data state. Emit the current tag token.
  | Set the self_closing flag of the current tag token. you Switch to the Data_state. you Emit the current tag token.
List(List((8,CHAIN8-["the current tag token" in sentence 1])), List((9,CHAIN9-["you" in sentence 2])), List((8,CHAIN8-["the current tag token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(VB,Token(-1,self_closing,self_closing)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(8,tag,tag)), Leaf(NN,Token(8,token,token))))))))))

 -> Set(the self_closing flag of the current tag token,on)
 -> Switch(Data_state)
 -> Emit(current tag token,8)

-- chara: EOF --
This is an eof-in-tag parse error. Emit an end-of-file token.
  | This is an eof_in_tag parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(VB,Token(-1,eof_in_tag,eof_in_tag)), Node(NML,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,parse,parse)))))))), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_tag parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is an unexpected-solidus-in-tag parse error. Reconsume in the before attribute name state.
  | This is an unexpected_solidus_in_tag parse error. you Reconsume in the Before_attribute_name_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(VB,Token(-1,unexpected_solidus_in_tag,unexpected_solidus_in_tag)), Node(NML,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,parse,parse)))))))), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_attribute_name_state,before_attribute_name_state))))))))))))

 -> Error(unexpected_solidus_in_tag parse error)
 -> Reconsume(Before_attribute_name_state)

41 : Bogus_comment_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the comment token.
  | you Switch to the Data_state. you Emit the comment token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(comment token,-1)

-- chara: EOF --
Emit the comment. Emit an end-of-file token.
  | you Emit the comment. you Emit an end_of_file token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(comment,-1)
 -> Emit(end_of_file token,-1)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the comment token's data.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the comment token's data.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the comment token 's data)

-- chara: Anything else --
Append the current input character to the comment token's data.
  | you Append the current input character to the comment token's data.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))

 -> Append(current input character,the comment token 's data)

42 : Markup_declaration_open_state
If the next few characters are: 
  | If the next few characters are: 
List(List())
Node(ROOT,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(JJ,Token(-1,few,few)), Leaf(NNS,Token(-1,characters,character)))), Node(VP,List(Leaf(VB,Token(-1,are,be)))))), Leaf(Colon,Token(-1,:,:))))))
### error_root


-- chara: Two U+002D HYPHEN-MINUS characters (-) --
Consume those two characters, create a comment token whose data is the empty string, and switch to the comment start state.
  | Consume those two characters, create a comment token whose data is the empty string, and you switch to the Comment_start_state.
List(List())
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,those,those)), Leaf(CD,Token(-1,two,two)), Leaf(NNS,Token(-1,characters,character)))))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,create,create)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)))), Node(SBAR,List(Node(WHNP,List(Leaf(WPD,Token(-1,whose,whose)), Node(NML,List(Leaf(NNS,Token(-1,data,datum)))))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))))))))))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_start_state,comment_start_state))))))))))))))

 -> Consume(two characters)
 -> Create(a comment token whose data is the empty string,-1)
 -> Switch(Comment_start_state)

-- chara: ASCII case-insensitive match for the word "DOCTYPE" --
Consume those characters and switch to the DOCTYPE state.
  | Consume those characters and you switch to the DOCTYPE_state.
List(List())
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,those,those)), Leaf(NNS,Token(-1,characters,character)))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_state,doctype_state))))))))))))))

 -> Consume(characters)
 -> Switch(DOCTYPE_state)

-- chara: The string "[CDATA[" (the five uppercase letters "CDATA" with a U+005B LEFT SQUARE BRACKET character before and after) --
Consume those characters. If there is an adjusted current node and it is not an element in the HTML namespace, then switch to the CDATA section state. Otherwise, this is a cdata-in-html-content parse error. Create a comment token whose data is the "[CDATA[" string. Switch to the bogus comment state.
  | Consume those characters. If there is an adjusted current node and it is not an element in the HTML namespace, then you switch to the CDATA_section_state. Otherwise, this is a cdata_in_html_content parse error. Create a comment token whose data is the "[CDATA[" string. you Switch to the Bogus_comment_state.
List(List(), List((16,CHAIN16-["you" in sentence 2]), (10,CHAIN10-["an adjusted current node" in sentence 2, "it" in sentence 2])), List((10,CHAIN10-["this" in sentence 3])), List(), List((16,CHAIN16-["you" in sentence 5])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,those,those)), Leaf(NNS,Token(-1,characters,character))))))))))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(S,List(Node(NP,List(Leaf(EX,Token(-1,there,there)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(10,adjusted,adjusted)), Leaf(JJ,Token(10,current,current)), Leaf(NN,Token(10,node,node)))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(NP,List(Leaf(PRP,Token(10,it,it)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Leaf(RB,Token(-1,not,not)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(NN,Token(-1,element,element)))), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,HTML,html)), Leaf(NN,Token(-1,namespace,namespace)))))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,CDATA_section_state,CDATA_section_state))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(10,this,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,cdata_in_html_content,cdata_in_html_content)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)))), Node(SBAR,List(Node(WHNP,List(Leaf(WPD,Token(-1,whose,whose)), Node(NML,List(Leaf(NNS,Token(-1,data,datum)))))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Node(NML,List(Node(NML,List(Leaf(NN,Token(-1,",")))), Leaf(LBracket,Token(-1,[,[)), Node(NML,List(Node(NML,List(Leaf(NNP,Token(-1,CDATA,cdata)))), Leaf(LBracket,Token(-1,[,[)), Node(NML,List(Leaf(NN,Token(-1,",")))))))), Leaf(NN,Token(-1,string,string))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_comment_state,Bogus_comment_state))))))))))))

 -> Consume(characters)
 -> If(And(IsExist(an adjusted current node),Not(IsEqual(it,an element in the HTML namespace))),List(Switch(CDATA_section_state)),List(Error(cdata_in_html_content parse error), Create(a comment token whose data is the " [ CDATA [ " string,-1), Switch(Bogus_comment_state)))

-- chara: Anything else --
This is an incorrectly-opened-comment parse error. Create a comment token whose data is the empty string. Switch to the bogus comment state (don't consume anything in the current state).
  | This is an incorrectly_opened_comment parse error. Create a comment token whose data is the empty string. you Switch to the Bogus_comment_state (don't consume anything in the current state).
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,incorrectly_opened_comment,incorrectly_opened_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)))), Node(SBAR,List(Node(WHNP,List(Leaf(WPD,Token(-1,whose,whose)), Node(NML,List(Leaf(NNS,Token(-1,data,datum)))))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_comment_state,bogus_comment_state))))))))))))

 -> Error(incorrectly_opened_comment parse error)
 -> Create(a comment token whose data is the empty string,-1)
 -> Switch(Bogus_comment_state)

43 : Comment_start_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the comment start dash state.
  | you Switch to the Comment_start_dash_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_start_dash_state,comment_start_dash_state))))))))))))

 -> Switch(Comment_start_dash_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is an abrupt-closing-of-empty-comment parse error. Switch to the data state. Emit the comment token.
  | This is an abrupt_closing_of_empty_comment parse error. you Switch to the Data_state. you Emit the comment token.
List(List(), List((6,CHAIN6-["you" in sentence 2])), List((6,CHAIN6-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,abrupt_closing_of_empty_comment,abrupt_closing_of_empty_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(abrupt_closing_of_empty_comment parse error)
 -> Switch(Data_state)
 -> Emit(comment token,-1)

-- chara: Anything else --
Reconsume in the comment state.
  | you Reconsume in the Comment_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_state,comment_state))))))))))))

 -> Reconsume(Comment_state)

44 : Comment_start_dash_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the comment end state
  | you Switch to the Comment_end_state
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_end_state,comment_end_state))))))))))))

 -> Switch(Comment_end_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is an abrupt-closing-of-empty-comment parse error. Switch to the data state. Emit the comment token.
  | This is an abrupt_closing_of_empty_comment parse error. you Switch to the Data_state. you Emit the comment token.
List(List(), List((6,CHAIN6-["you" in sentence 2])), List((6,CHAIN6-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,abrupt_closing_of_empty_comment,abrupt_closing_of_empty_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(abrupt_closing_of_empty_comment parse error)
 -> Switch(Data_state)
 -> Emit(comment token,-1)

-- chara: EOF --
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
  | This is an eof_in_comment parse error. you Emit the comment token. you Emit an end_of_file token.
List(List(), List((5,CHAIN5-["you" in sentence 2])), List((5,CHAIN5-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_comment,eof_in_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_comment parse error)
 -> Emit(comment token,-1)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data. Reconsume in the comment state.
  | you Append a U_002D HYPHEN_MINUS character (_) to the comment token's data. you Reconsume in the Comment_state.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNS,Token(-1,HYPHEN_MINUS,HYPHEN_MINUS)), Leaf(NN,Token(-1,character,character)))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_state,comment_state))))))))))))

 -> Append(a U_002D HYPHEN_MINUS character,the comment token 's data)
 -> Reconsume(Comment_state)

45 : Comment_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Append the current input character to the comment token's data. Switch to the comment less-than sign state.
  | you Append the current input character to the comment token's data. you Switch to the Comment_less_than_sign_state.
List(List((7,CHAIN7-["you" in sentence 1])), List((7,CHAIN7-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_less_than_sign_state,comment_less_than_sign_state))))))))))))

 -> Append(current input character,the comment token 's data)
 -> Switch(Comment_less_than_sign_state)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the comment end dash state.
  | you Switch to the Comment_end_dash_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_end_dash_state,comment_end_dash_state))))))))))))

 -> Switch(Comment_end_dash_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the comment token's data.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the comment token's data.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the comment token 's data)

-- chara: EOF --
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
  | This is an eof_in_comment parse error. you Emit the comment token. you Emit an end_of_file token.
List(List(), List((5,CHAIN5-["you" in sentence 2])), List((5,CHAIN5-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_comment,eof_in_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_comment parse error)
 -> Emit(comment token,-1)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the comment token's data.
  | you Append the current input character to the comment token's data.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))

 -> Append(current input character,the comment token 's data)

46 : Comment_less_than_sign_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0021 EXCLAMATION MARK (!) --
Append the current input character to the comment token's data. Switch to the comment less-than sign bang state.
  | you Append the current input character to the comment token's data. you Switch to the Comment_less_than_sign_bang_state.
List(List((7,CHAIN7-["you" in sentence 1])), List((7,CHAIN7-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_less_than_sign_bang_state,comment_less_than_sign_bang_state))))))))))))

 -> Append(current input character,the comment token 's data)
 -> Switch(Comment_less_than_sign_bang_state)

-- chara: U+003C LESS-THAN SIGN (&lt;) --
Append the current input character to the comment token's data.
  | you Append the current input character to the comment token's data.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))

 -> Append(current input character,the comment token 's data)

-- chara: Anything else --
Reconsume in the comment state.
  | you Reconsume in the Comment_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_state,comment_state))))))))))))

 -> Reconsume(Comment_state)

47 : Comment_less_than_sign_bang_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the comment less-than sign bang dash state.
  | you Switch to the Comment_less_than_sign_bang_dash_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_less_than_sign_bang_dash_state,comment_less_than_sign_bang_dash_state))))))))))))

 -> Switch(Comment_less_than_sign_bang_dash_state)

-- chara: Anything else --
Reconsume in the comment state.
  | you Reconsume in the Comment_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_state,comment_state))))))))))))

 -> Reconsume(Comment_state)

48 : Comment_less_than_sign_bang_dash_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the comment less-than sign bang dash dash state.
  | you Switch to the Comment_less_than_sign_bang_dash_dash_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_less_than_sign_bang_dash_dash_state,comment_less_than_sign_bang_dash_dash_state))))))))))))

 -> Switch(Comment_less_than_sign_bang_dash_dash_state)

-- chara: Anything else --
Reconsume in the comment end dash state.
  | you Reconsume in the Comment_end_dash_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_end_dash_state,comment_end_dash_state))))))))))))

 -> Reconsume(Comment_end_dash_state)

49 : Comment_less_than_sign_bang_dash_dash_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Reconsume in the comment end state.
  | you Reconsume in the Comment_end_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_end_state,comment_end_state))))))))))))

 -> Reconsume(Comment_end_state)

-- chara: EOF --
Reconsume in the comment end state.
  | you Reconsume in the Comment_end_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_end_state,comment_end_state))))))))))))

 -> Reconsume(Comment_end_state)

-- chara: Anything else --
This is a nested-comment parse error. Reconsume in the comment end state.
  | This is a nested_comment parse error. you Reconsume in the Comment_end_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,nested_comment,nested_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_end_state,comment_end_state))))))))))))

 -> Error(nested_comment parse error)
 -> Reconsume(Comment_end_state)

50 : Comment_end_dash_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Switch to the comment end state
  | you Switch to the Comment_end_state
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_end_state,comment_end_state))))))))))))

 -> Switch(Comment_end_state)

-- chara: EOF --
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
  | This is an eof_in_comment parse error. you Emit the comment token. you Emit an end_of_file token.
List(List(), List((5,CHAIN5-["you" in sentence 2])), List((5,CHAIN5-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_comment,eof_in_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_comment parse error)
 -> Emit(comment token,-1)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data. Reconsume in the comment state.
  | you Append a U_002D HYPHEN_MINUS character (_) to the comment token's data. you Reconsume in the Comment_state.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNS,Token(-1,HYPHEN_MINUS,HYPHEN_MINUS)), Leaf(NN,Token(-1,character,character)))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_state,comment_state))))))))))))

 -> Append(a U_002D HYPHEN_MINUS character,the comment token 's data)
 -> Reconsume(Comment_state)

51 : Comment_end_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the comment token.
  | you Switch to the Data_state. you Emit the comment token.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(comment token,-1)

-- chara: U+0021 EXCLAMATION MARK (!) --
Switch to the comment end bang state.
  | you Switch to the Comment_end_bang_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_end_bang_state,comment_end_bang_state))))))))))))

 -> Switch(Comment_end_bang_state)

-- chara: U+002D HYPHEN-MINUS (-) --
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data.
  | you Append a U_002D HYPHEN_MINUS character (_) to the comment token's data.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NNS,Token(-1,HYPHEN_MINUS,HYPHEN_MINUS)), Leaf(NN,Token(-1,character,character)))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))

 -> Append(a U_002D HYPHEN_MINUS character,the comment token 's data)

-- chara: EOF --
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
  | This is an eof_in_comment parse error. you Emit the comment token. you Emit an end_of_file token.
List(List(), List((5,CHAIN5-["you" in sentence 2])), List((5,CHAIN5-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_comment,eof_in_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_comment parse error)
 -> Emit(comment token,-1)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append two U+002D HYPHEN-MINUS characters (-) to the comment token's data. Reconsume in the comment state.
  | you Append two U_002D HYPHEN_MINUS characters (_) to the comment token's data. you Reconsume in the Comment_state.
List(List((7,CHAIN7-["you" in sentence 1])), List((7,CHAIN7-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(CD,Token(-1,two,two)), Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NN,Token(-1,HYPHEN_MINUS,HYPHEN_MINUS)), Leaf(NNS,Token(-1,characters,character)))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_state,comment_state))))))))))))

 -> Append(two U_002D HYPHEN_MINUS characters,the comment token 's data)
 -> Reconsume(Comment_state)

52 : Comment_end_bang_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+002D HYPHEN-MINUS (-) --
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character (-EXC-) to the comment token's data. Switch to the comment end dash state.
  | you Append two U_002D HYPHEN_MINUS characters (_) and a U_0021 EXCLAMATION MARK character (_EXC_) to the comment token's data. you Switch to the Comment_end_dash_state.
List(List((13,CHAIN13-["you" in sentence 1])), List((13,CHAIN13-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(CD,Token(-1,two,two)), Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NN,Token(-1,HYPHEN_MINUS,HYPHEN_MINUS)), Leaf(NNS,Token(-1,characters,character)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NNP,Token(-1,U_0021,u_0021)), Leaf(NNP,Token(-1,EXCLAMATION,EXCLAMATION)), Leaf(NNP,Token(-1,MARK,MARK)))), Node(NP,List(Leaf(NN,Token(-1,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_end_dash_state,comment_end_dash_state))))))))))))

 -> Append(two U_002D HYPHEN_MINUS characters,the comment token 's data)
 -> Append(a U_0021 EXCLAMATION MARK character,the comment token 's data)
 -> Switch(Comment_end_dash_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is an incorrectly-closed-comment parse error. Switch to the data state. Emit the comment token.
  | This is an incorrectly_closed_comment parse error. you Switch to the Data_state. you Emit the comment token.
List(List(), List((6,CHAIN6-["you" in sentence 2])), List((6,CHAIN6-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,incorrectly_closed_comment,incorrectly_closed_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(incorrectly_closed_comment parse error)
 -> Switch(Data_state)
 -> Emit(comment token,-1)

-- chara: EOF --
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
  | This is an eof_in_comment parse error. you Emit the comment token. you Emit an end_of_file token.
List(List(), List((5,CHAIN5-["you" in sentence 2])), List((5,CHAIN5-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_comment,eof_in_comment)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_comment parse error)
 -> Emit(comment token,-1)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character (!) to the comment token's data. Reconsume in the comment state.
  | you Append two U_002D HYPHEN_MINUS characters (_) and a U_0021 EXCLAMATION MARK character (EXC) to the comment token's data. you Reconsume in the Comment_state.
List(List((10,CHAIN10-["you" in sentence 1])), List((10,CHAIN10-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(CD,Token(-1,two,two)), Leaf(NNP,Token(-1,U_002D,u_002d)), Leaf(NN,Token(-1,HYPHEN_MINUS,HYPHEN_MINUS)), Leaf(NNS,Token(-1,characters,character)))), Leaf(CC,Token(-1,and,and)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NNP,Token(-1,U_0021,u_0021)), Leaf(NNP,Token(-1,EXCLAMATION,EXCLAMATION)), Leaf(NNP,Token(-1,MARK,MARK)))), Node(NP,List(Leaf(NN,Token(-1,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,comment,comment)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NNS,Token(-1,data,datum))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Comment_state,comment_state))))))))))))

 -> Append(two U_002D HYPHEN_MINUS characters,the comment token 's data)
 -> Append(a U_0021 EXCLAMATION MARK character,the comment token 's data)
 -> Reconsume(Comment_state)

53 : DOCTYPE_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Switch to the before DOCTYPE name state.
  | you Switch to the Before_DOCTYPE_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_name_state,before_doctype_name_state))))))))))))

 -> Switch(Before_DOCTYPE_name_state)

-- chara: U+000A LINE FEED (LF) --
Switch to the before DOCTYPE name state.
  | you Switch to the Before_DOCTYPE_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_name_state,before_doctype_name_state))))))))))))

 -> Switch(Before_DOCTYPE_name_state)

-- chara: U+000C FORM FEED (FF) --
Switch to the before DOCTYPE name state.
  | you Switch to the Before_DOCTYPE_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_name_state,before_doctype_name_state))))))))))))

 -> Switch(Before_DOCTYPE_name_state)

-- chara: U+0020 SPACE --
Switch to the before DOCTYPE name state.
  | you Switch to the Before_DOCTYPE_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_name_state,before_doctype_name_state))))))))))))

 -> Switch(Before_DOCTYPE_name_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Reconsume in the before DOCTYPE name state.
  | you Reconsume in the Before_DOCTYPE_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_name_state,before_doctype_name_state))))))))))))

 -> Reconsume(Before_DOCTYPE_name_state)

-- chara: EOF --
This is an eof-in-doctype parse error. Create a new DOCTYPE token. Set its force-quirks flag to on. Emit the token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Create a new DOCTYPE token and Set its force_quirks flag to on. you Emit the token. you Emit an end_of_file token.
List(List(), List((5,CHAIN5-["a new DOCTYPE token" in sentence 2, "its" in sentence 2])), List((5,CHAIN5-["the token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(5,a,a)), Leaf(JJ,Token(5,new,new)), Leaf(JJ,Token(5,DOCTYPE,doctype)), Leaf(NN,Token(5,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(PRPD,Token(5,its,its)), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(5,the,the)), Leaf(NN,Token(5,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Create(new DOCTYPE token,5)
 -> Set(its force_quirks flag,on)
 -> Emit(token,5)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is a missing-whitespace-before-doctype-name parse error. Reconsume in the before DOCTYPE name state. 
  | This is a missing_whitespace_before_doctype_name parse error. you Reconsume in the Before_DOCTYPE_name_state. 
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_whitespace_before_doctype_name,missing_whitespace_before_doctype_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_name_state,before_doctype_name_state))))))))))))

 -> Error(missing_whitespace_before_doctype_name parse error)
 -> Reconsume(Before_DOCTYPE_name_state)

54 : Before_DOCTYPE_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000A LINE FEED (LF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000C FORM FEED (FF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0020 SPACE --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: ASCII upper alpha --
Create a new DOCTYPE token. Set the token's name to the lowercase version of the current input character (add 0x0020 to the character's code point). Switch to the DOCTYPE name state.
  | Create a new DOCTYPE token and Set the token's name to the lowercase version of the current input character (you add 0x0020 to the character's code point). you Switch to the DOCTYPE_name_state.
List(List((4,CHAIN4-["a new DOCTYPE token" in sentence 1, "the token 's" in sentence 1]), (9,CHAIN9-["the current input character" in sentence 1, "the character 's" in sentence 1]), (13,CHAIN13-["you" in sentence 1])), List((13,CHAIN13-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(4,a,a)), Leaf(JJ,Token(4,new,new)), Leaf(JJ,Token(4,DOCTYPE,doctype)), Leaf(NN,Token(4,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(9,the,the)), Leaf(NN,Token(4,token,token)), Leaf(POS,Token(9,'s,'s)))), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(9,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(9,the,the)), Leaf(JJ,Token(9,current,current)), Leaf(NN,Token(9,input,input)), Leaf(NN,Token(9,character,character))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_name_state,doctype_name_state))))))))))))

 -> Create(new DOCTYPE token,4)
 -> Set(the token 's name,the lowercase version of the current input character)
 -> Switch(DOCTYPE_name_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Create a new DOCTYPE token. Set the token's name to a U+FFFD REPLACEMENT CHARACTER character. Switch to the DOCTYPE name state.
  | This is an unexpected_null_character parse error. Create a new DOCTYPE token and Set the token's name to a U_FFFD REPLACEMENT CHARACTER character. you Switch to the DOCTYPE_name_state.
List(List(), List((4,CHAIN4-["a new DOCTYPE token" in sentence 2, "the token 's" in sentence 2])), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(4,new,new)), Leaf(JJ,Token(4,DOCTYPE,doctype)), Leaf(NN,Token(4,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(4,the,the)), Leaf(NN,Token(4,token,token)), Leaf(POS,Token(4,'s,'s)))), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(VB,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_name_state,doctype_name_state))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Create(new DOCTYPE token,4)
 -> Set(the token 's name,a U_FFFD REPLACEMENT CHARACTER character)
 -> Switch(DOCTYPE_name_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is a missing-doctype-name parse error. Create a new DOCTYPE token. Set its force-quirks flag to on. Switch to the data state. Emit the token.
  | This is a missing_doctype_name parse error. Create a new DOCTYPE token and Set its force_quirks flag to on. you Switch to the Data_state. you Emit the token.
List(List(), List((5,CHAIN5-["a new DOCTYPE token" in sentence 2, "its" in sentence 2])), List((10,CHAIN10-["you" in sentence 3])), List((5,CHAIN5-["the token" in sentence 4]), (10,CHAIN10-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_doctype_name,missing_doctype_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(5,a,a)), Leaf(JJ,Token(5,new,new)), Leaf(JJ,Token(5,DOCTYPE,doctype)), Leaf(NN,Token(5,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(PRPD,Token(5,its,its)), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(5,the,the)), Leaf(NN,Token(5,token,token))))))))))

 -> Error(missing_doctype_name parse error)
 -> Create(new DOCTYPE token,5)
 -> Set(its force_quirks flag,on)
 -> Switch(Data_state)
 -> Emit(token,5)

-- chara: EOF --
This is an eof-in-doctype parse error. Create a new DOCTYPE token. Set its  force-quirks flag to on. Emit the token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Create a new DOCTYPE token and Set its  force_quirks flag to on. you Emit the token. you Emit an end_of_file token.
List(List(), List((5,CHAIN5-["a new DOCTYPE token" in sentence 2, "its" in sentence 2])), List((5,CHAIN5-["the token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(5,a,a)), Leaf(JJ,Token(5,new,new)), Leaf(JJ,Token(5,DOCTYPE,doctype)), Leaf(NN,Token(5,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(PRPD,Token(5,its,its)), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(5,the,the)), Leaf(NN,Token(5,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Create(new DOCTYPE token,5)
 -> Set(its force_quirks flag,on)
 -> Emit(token,5)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Create a new DOCTYPE token. Set the token's name to the current input character. Switch to the DOCTYPE name state.
  | Create a new DOCTYPE token and Set the token's name to the current input character. you Switch to the DOCTYPE_name_state.
List(List((3,CHAIN3-["a new DOCTYPE token" in sentence 1, "the token 's" in sentence 1])), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Node(VP,List(Leaf(VB,Token(-1,Create,create)), Node(NP,List(Leaf(DT,Token(3,a,a)), Leaf(JJ,Token(3,new,new)), Leaf(JJ,Token(3,DOCTYPE,doctype)), Leaf(NN,Token(3,token,token)))))), Leaf(CC,Token(-1,and,and)), Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(3,token,token)), Leaf(POS,Token(3,'s,'s)))), Leaf(NN,Token(-1,name,name)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_name_state,doctype_name_state))))))))))))

 -> Create(new DOCTYPE token,3)
 -> Set(the token 's name,the current input character)
 -> Switch(DOCTYPE_name_state)

55 : DOCTYPE_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Switch to the after DOCTYPE name state.
  | you Switch to the After_DOCTYPE_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_name_state,after_doctype_name_state))))))))))))

 -> Switch(After_DOCTYPE_name_state)

-- chara: U+000A LINE FEED (LF) --
Switch to the after DOCTYPE name state.
  | you Switch to the After_DOCTYPE_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_name_state,after_doctype_name_state))))))))))))

 -> Switch(After_DOCTYPE_name_state)

-- chara: U+000C FORM FEED (FF) --
Switch to the after DOCTYPE name state.
  | you Switch to the After_DOCTYPE_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_name_state,after_doctype_name_state))))))))))))

 -> Switch(After_DOCTYPE_name_state)

-- chara: U+0020 SPACE --
Switch to the after DOCTYPE name state.
  | you Switch to the After_DOCTYPE_name_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_name_state,after_doctype_name_state))))))))))))

 -> Switch(After_DOCTYPE_name_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the current DOCTYPE token.
  | you Switch to the Data_state. you Emit the current DOCTYPE token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(current DOCTYPE token,-1)

-- chara: ASCII upper alpha --
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current DOCTYPE token's name.
  | you Append the lowercase version of the current input character (you add 0x0020 to the character's code point) to the current DOCTYPE token's name.
List(List((6,CHAIN6-["you" in sentence 1, "you" in sentence 1]), (7,CHAIN7-["the current input character" in sentence 1, "the character 's" in sentence 1])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,lowercase,lowercase)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(7,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,name,name))))))))))))

 -> Append(the lowercase version of the current input character,the current DOCTYPE token 's name)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's name.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's name.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,name,name))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's name)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the current DOCTYPE token's name.
  | you Append the current input character to the current DOCTYPE token's name.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,name,name))))))))))))

 -> Append(current input character,the current DOCTYPE token 's name)

56 : After_DOCTYPE_name_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000A LINE FEED (LF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000C FORM FEED (FF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0020 SPACE --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the current DOCTYPE token.
  | you Switch to the Data_state. you Emit the current DOCTYPE token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(current DOCTYPE token,-1)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
 If the six characters starting from the current input character are an ASCII case-insensitive match for the word "PUBLIC", then consume those characters and switch to the after DOCTYPE public keyword state. Otherwise, if the six characters starting from the current input character are an ASCII case-insensitive match for the word "SYSTEM", then consume those characters and switch to the after DOCTYPE system keyword state. Otherwise, this is an invalid-character-sequence-after-doctype-name parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state. 
  |  If the six characters starting from the current input character are an ASCII case_insensitive match for the word "PUBLIC", then consume those characters and you switch to the After_DOCTYPE_public_keyword_state. Otherwise, if the six characters starting from the current input character are an ASCII case_insensitive match for the word "SYSTEM", then consume those characters and you switch to the After_DOCTYPE_system_keyword_state. Otherwise, this is an invalid_character_sequence_after_doctype_name parse error. Set the DOCTYPE token's force_quirks flag to on. you Reconsume in the Bogus_DOCTYPE_state. 
List(List((20,CHAIN20-["the six characters starting from the current input character" in sentence 1, "those characters" in sentence 1]), (12,CHAIN12-["the current input character" in sentence 1])), List((20,CHAIN20-["the six characters starting from the current input character" in sentence 2, "those characters" in sentence 2]), (12,CHAIN12-["the current input character" in sentence 2])), List((20,CHAIN20-["this" in sentence 3])), List(), List())
Node(ROOT,List(Node(S,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(CD,Token(20,six,six)), Leaf(NNS,Token(20,characters,character)))), Node(VP,List(Leaf(VB,Token(20,starting,start)), Node(PP,List(Leaf(IN,Token(20,from,from)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(12,current,current)), Leaf(NN,Token(12,input,input)), Leaf(NN,Token(12,character,character)))))))))), Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(NNP,Token(-1,ASCII,ascii)), Leaf(NN,Token(-1,case_insensitive,case_insensitive)), Leaf(NN,Token(-1,match,match)))), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,word,word)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NNP,Token(-1,PUBLIC,PUBLIC)), Leaf(RDoubleQuote,Token(-1,",")))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,consume,consume)), Node(NP,List(Leaf(DT,Token(20,those,those)), Leaf(NNS,Token(20,characters,character)))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_public_keyword_state,after_doctype_public_keyword_state))))))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(S,List(Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(CD,Token(20,six,six)), Leaf(NNS,Token(20,characters,character)))), Node(VP,List(Leaf(VB,Token(20,starting,start)), Node(PP,List(Leaf(IN,Token(20,from,from)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(12,current,current)), Leaf(NN,Token(12,input,input)), Leaf(NN,Token(12,character,character)))))))))), Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(NNP,Token(-1,ASCII,ascii)), Leaf(NN,Token(-1,case_insensitive,case_insensitive)), Leaf(NN,Token(-1,match,match)))), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,word,word)), Leaf(LDoubleQuote,Token(-1,",")), Leaf(NNP,Token(-1,SYSTEM,system)), Leaf(RDoubleQuote,Token(-1,",")))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,consume,consume)), Node(NP,List(Leaf(DT,Token(20,those,those)), Leaf(NNS,Token(20,characters,character)))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_system_keyword_state,after_doctype_system_keyword_state))))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(20,this,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,invalid_character_sequence_after_doctype_name,invalid_character_sequence_after_doctype_name)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_DOCTYPE_state,Bogus_DOCTYPE_state))))))))))))

 -> If(IsEqual(the six characters starting from the current input character,an ASCII case_insensitive match for the word " PUBLIC "),List(Consume(characters), Switch(After_DOCTYPE_public_keyword_state)),List(If(IsEqual(the six characters starting from the current input character,an ASCII case_insensitive match for the word " SYSTEM "),List(Consume(characters), Switch(After_DOCTYPE_system_keyword_state)),List(Error(invalid_character_sequence_after_doctype_name parse error), Set(the DOCTYPE token 's force_quirks flag,on), Reconsume(Bogus_DOCTYPE_state)))))

57 : After_DOCTYPE_public_keyword_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Switch to the before DOCTYPE public identifier state.
  | you Switch to the Before_DOCTYPE_public_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_public_identifier_state,before_doctype_public_identifier_state))))))))))))

 -> Switch(Before_DOCTYPE_public_identifier_state)

-- chara: U+000A LINE FEED (LF) --
Switch to the before DOCTYPE public identifier state.
  | you Switch to the Before_DOCTYPE_public_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_public_identifier_state,before_doctype_public_identifier_state))))))))))))

 -> Switch(Before_DOCTYPE_public_identifier_state)

-- chara: U+000C FORM FEED (FF) --
Switch to the before DOCTYPE public identifier state.
  | you Switch to the Before_DOCTYPE_public_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_public_identifier_state,before_doctype_public_identifier_state))))))))))))

 -> Switch(Before_DOCTYPE_public_identifier_state)

-- chara: U+0020 SPACE --
Switch to the before DOCTYPE public identifier state.
  | you Switch to the Before_DOCTYPE_public_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_public_identifier_state,before_doctype_public_identifier_state))))))))))))

 -> Switch(Before_DOCTYPE_public_identifier_state)

-- chara: U+0022 QUOTATION MARK (") --
This is a missing-whitespace-after-doctype-public-keyword parse error. Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (double-quoted) state.
  | This is a missing_whitespace_after_doctype_public_keyword parse error. Set the DOCTYPE token's public identifier to the empty string (not missing), then you switch to the DOCTYPE_public_identifier_double_quoted_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_whitespace_after_doctype_public_keyword,missing_whitespace_after_doctype_public_keyword)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,public,public)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_public_identifier_double_quoted_state,doctype_public_identifier_double_quoted_state))))))))))))

 -> Error(missing_whitespace_after_doctype_public_keyword parse error)
 -> Set(the DOCTYPE token 's public identifier,the empty string)
 -> Switch(DOCTYPE_public_identifier_double_quoted_state)

-- chara: U+0027 APOSTROPHE (') --
This is a missing-whitespace-after-doctype-public-keyword parse error. Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (single-quoted) state.
  | This is a missing_whitespace_after_doctype_public_keyword parse error. Set the DOCTYPE token's public identifier to the empty string (not missing), then you switch to the DOCTYPE_public_identifier_single_quoted_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_whitespace_after_doctype_public_keyword,missing_whitespace_after_doctype_public_keyword)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,public,public)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_public_identifier_single_quoted_state,doctype_public_identifier_single_quoted_state))))))))))))

 -> Error(missing_whitespace_after_doctype_public_keyword parse error)
 -> Set(the DOCTYPE token 's public identifier,the empty string)
 -> Switch(DOCTYPE_public_identifier_single_quoted_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is a missing-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
  | This is a missing_doctype_public_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Switch to the Data_state. you Emit that DOCTYPE token.
List(List(), List((10,CHAIN10-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["you" in sentence 3])), List((8,CHAIN8-["you" in sentence 4]), (10,CHAIN10-["that DOCTYPE token" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_doctype_public_identifier,missing_doctype_public_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(10,DOCTYPE,doctype)), Leaf(NN,Token(10,token,token)), Leaf(POS,Token(10,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(10,that,that)), Leaf(JJ,Token(10,DOCTYPE,doctype)), Leaf(NN,Token(10,token,token))))))))))

 -> Error(missing_doctype_public_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Switch(Data_state)
 -> Emit(DOCTYPE token,10)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is a missing-quote-before-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
  | This is a missing_quote_before_doctype_public_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Reconsume in the Bogus_DOCTYPE_state.
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_quote_before_doctype_public_identifier,missing_quote_before_doctype_public_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_DOCTYPE_state,Bogus_DOCTYPE_state))))))))))))

 -> Error(missing_quote_before_doctype_public_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Reconsume(Bogus_DOCTYPE_state)

58 : Before_DOCTYPE_public_identifier_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000A LINE FEED (LF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000C FORM FEED (FF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0020 SPACE --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0022 QUOTATION MARK (") --
Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (double-quoted) state.
  | Set the DOCTYPE token's public identifier to the empty string (not missing), then you switch to the DOCTYPE_public_identifier_double_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,public,public)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_public_identifier_double_quoted_state,doctype_public_identifier_double_quoted_state))))))))))))

 -> Set(the DOCTYPE token 's public identifier,the empty string)
 -> Switch(DOCTYPE_public_identifier_double_quoted_state)

-- chara: U+0027 APOSTROPHE (') --
Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (single-quoted) state.
  | Set the DOCTYPE token's public identifier to the empty string (not missing), then you switch to the DOCTYPE_public_identifier_single_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,public,public)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_public_identifier_single_quoted_state,doctype_public_identifier_single_quoted_state))))))))))))

 -> Set(the DOCTYPE token 's public identifier,the empty string)
 -> Switch(DOCTYPE_public_identifier_single_quoted_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is a missing-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
  | This is a missing_doctype_public_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Switch to the Data_state. you Emit that DOCTYPE token.
List(List(), List((10,CHAIN10-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["you" in sentence 3])), List((8,CHAIN8-["you" in sentence 4]), (10,CHAIN10-["that DOCTYPE token" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_doctype_public_identifier,missing_doctype_public_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(10,DOCTYPE,doctype)), Leaf(NN,Token(10,token,token)), Leaf(POS,Token(10,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(10,that,that)), Leaf(JJ,Token(10,DOCTYPE,doctype)), Leaf(NN,Token(10,token,token))))))))))

 -> Error(missing_doctype_public_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Switch(Data_state)
 -> Emit(DOCTYPE token,10)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is a missing-quote-before-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
  | This is a missing_quote_before_doctype_public_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Reconsume in the Bogus_DOCTYPE_state.
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_quote_before_doctype_public_identifier,missing_quote_before_doctype_public_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_DOCTYPE_state,Bogus_DOCTYPE_state))))))))))))

 -> Error(missing_quote_before_doctype_public_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Reconsume(Bogus_DOCTYPE_state)

59 : DOCTYPE_public_identifier_double_quoted_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0022 QUOTATION MARK (") --
Switch to the after DOCTYPE public identifier state.
  | you Switch to the After_DOCTYPE_public_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_public_identifier_state,after_doctype_public_identifier_state))))))))))))

 -> Switch(After_DOCTYPE_public_identifier_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,public,public)), Leaf(NN,Token(-1,identifier,identifier))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's public identifier)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is an abrupt-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
  | This is an abrupt_doctype_public_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Switch to the Data_state. you Emit that DOCTYPE token.
List(List(), List((11,CHAIN11-["the DOCTYPE token 's" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4]), (11,CHAIN11-["that DOCTYPE token" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,abrupt_doctype_public_identifier,abrupt_doctype_public_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(11,DOCTYPE,doctype)), Leaf(NN,Token(11,token,token)), Leaf(POS,Token(11,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(11,that,that)), Leaf(JJ,Token(11,DOCTYPE,doctype)), Leaf(NN,Token(11,token,token))))))))))

 -> Error(abrupt_doctype_public_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Switch(Data_state)
 -> Emit(DOCTYPE token,11)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the current DOCTYPE token's public identifier.
  | you Append the current input character to the current DOCTYPE token's public identifier.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,public,public)), Leaf(NN,Token(-1,identifier,identifier))))))))))))

 -> Append(current input character,the current DOCTYPE token 's public identifier)

60 : DOCTYPE_public_identifier_single_quoted_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0027 APOSTROPHE (') --
Switch to the after DOCTYPE public identifier state.
  | you Switch to the After_DOCTYPE_public_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_public_identifier_state,after_doctype_public_identifier_state))))))))))))

 -> Switch(After_DOCTYPE_public_identifier_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,public,public)), Leaf(NN,Token(-1,identifier,identifier))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's public identifier)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is an abrupt-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
  | This is an abrupt_doctype_public_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Switch to the Data_state. you Emit that DOCTYPE token.
List(List(), List((11,CHAIN11-["the DOCTYPE token 's" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4]), (11,CHAIN11-["that DOCTYPE token" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,abrupt_doctype_public_identifier,abrupt_doctype_public_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(11,DOCTYPE,doctype)), Leaf(NN,Token(11,token,token)), Leaf(POS,Token(11,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(11,that,that)), Leaf(JJ,Token(11,DOCTYPE,doctype)), Leaf(NN,Token(11,token,token))))))))))

 -> Error(abrupt_doctype_public_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Switch(Data_state)
 -> Emit(DOCTYPE token,11)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the current DOCTYPE token's public identifier.
  | you Append the current input character to the current DOCTYPE token's public identifier.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,public,public)), Leaf(NN,Token(-1,identifier,identifier))))))))))))

 -> Append(current input character,the current DOCTYPE token 's public identifier)

61 : After_DOCTYPE_public_identifier_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Switch to the between DOCTYPE public and system identifiers state.
  | you Switch to the Between_DOCTYPE_public_and_system_identifiers_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Between_DOCTYPE_public_and_system_identifiers_state,between_doctype_public_and_system_identifiers_state))))))))))))

 -> Switch(Between_DOCTYPE_public_and_system_identifiers_state)

-- chara: U+000A LINE FEED (LF) --
Switch to the between DOCTYPE public and system identifiers state.
  | you Switch to the Between_DOCTYPE_public_and_system_identifiers_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Between_DOCTYPE_public_and_system_identifiers_state,between_doctype_public_and_system_identifiers_state))))))))))))

 -> Switch(Between_DOCTYPE_public_and_system_identifiers_state)

-- chara: U+000C FORM FEED (FF) --
Switch to the between DOCTYPE public and system identifiers state.
  | you Switch to the Between_DOCTYPE_public_and_system_identifiers_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Between_DOCTYPE_public_and_system_identifiers_state,between_doctype_public_and_system_identifiers_state))))))))))))

 -> Switch(Between_DOCTYPE_public_and_system_identifiers_state)

-- chara: U+0020 SPACE --
Switch to the between DOCTYPE public and system identifiers state.
  | you Switch to the Between_DOCTYPE_public_and_system_identifiers_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Between_DOCTYPE_public_and_system_identifiers_state,between_doctype_public_and_system_identifiers_state))))))))))))

 -> Switch(Between_DOCTYPE_public_and_system_identifiers_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the current DOCTYPE token.
  | you Switch to the Data_state. you Emit the current DOCTYPE token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(current DOCTYPE token,-1)

-- chara: U+0022 QUOTATION MARK (") --
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
  | This is a missing_whitespace_between_doctype_public_and_system_identifiers parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then you switch to the DOCTYPE_system_identifier_double_quoted_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_whitespace_between_doctype_public_and_system_identifiers,missing_whitespace_between_doctype_public_and_system_identifiers)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_system_identifier_double_quoted_state,doctype_system_identifier_double_quoted_state))))))))))))

 -> Error(missing_whitespace_between_doctype_public_and_system_identifiers parse error)
 -> Set(the DOCTYPE token 's system identifier,the empty string)
 -> Switch(DOCTYPE_system_identifier_double_quoted_state)

-- chara: U+0027 APOSTROPHE (') --
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
  | This is a missing_whitespace_between_doctype_public_and_system_identifiers parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then you switch to the DOCTYPE_system_identifier_single_quoted_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_whitespace_between_doctype_public_and_system_identifiers,missing_whitespace_between_doctype_public_and_system_identifiers)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_system_identifier_single_quoted_state,doctype_system_identifier_single_quoted_state))))))))))))

 -> Error(missing_whitespace_between_doctype_public_and_system_identifiers parse error)
 -> Set(the DOCTYPE token 's system identifier,the empty string)
 -> Switch(DOCTYPE_system_identifier_single_quoted_state)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is a missing-quote-before-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
  | This is a missing_quote_before_doctype_system_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Reconsume in the Bogus_DOCTYPE_state.
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_quote_before_doctype_system_identifier,missing_quote_before_doctype_system_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_DOCTYPE_state,Bogus_DOCTYPE_state))))))))))))

 -> Error(missing_quote_before_doctype_system_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Reconsume(Bogus_DOCTYPE_state)

62 : Between_DOCTYPE_public_and_system_identifiers_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000A LINE FEED (LF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000C FORM FEED (FF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0020 SPACE --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the current DOCTYPE token.
  | you Switch to the Data_state. you Emit the current DOCTYPE token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(current DOCTYPE token,-1)

-- chara: U+0022 QUOTATION MARK (") --
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
  | Set the DOCTYPE token's system identifier to the empty string (not missing), then you switch to the DOCTYPE_system_identifier_double_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_system_identifier_double_quoted_state,doctype_system_identifier_double_quoted_state))))))))))))

 -> Set(the DOCTYPE token 's system identifier,the empty string)
 -> Switch(DOCTYPE_system_identifier_double_quoted_state)

-- chara: U+0027 APOSTROPHE (') --
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
  | Set the DOCTYPE token's system identifier to the empty string (not missing), then you switch to the DOCTYPE_system_identifier_single_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_system_identifier_single_quoted_state,doctype_system_identifier_single_quoted_state))))))))))))

 -> Set(the DOCTYPE token 's system identifier,the empty string)
 -> Switch(DOCTYPE_system_identifier_single_quoted_state)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is a missing-quote-before-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
  | This is a missing_quote_before_doctype_system_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Reconsume in the Bogus_DOCTYPE_state.
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_quote_before_doctype_system_identifier,missing_quote_before_doctype_system_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_DOCTYPE_state,Bogus_DOCTYPE_state))))))))))))

 -> Error(missing_quote_before_doctype_system_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Reconsume(Bogus_DOCTYPE_state)

63 : After_DOCTYPE_system_keyword_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Switch to the before DOCTYPE system identifier state.
  | you Switch to the Before_DOCTYPE_system_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_system_identifier_state,before_doctype_system_identifier_state))))))))))))

 -> Switch(Before_DOCTYPE_system_identifier_state)

-- chara: U+000A LINE FEED (LF) --
Switch to the before DOCTYPE system identifier state.
  | you Switch to the Before_DOCTYPE_system_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_system_identifier_state,before_doctype_system_identifier_state))))))))))))

 -> Switch(Before_DOCTYPE_system_identifier_state)

-- chara: U+000C FORM FEED (FF) --
Switch to the before DOCTYPE system identifier state.
  | you Switch to the Before_DOCTYPE_system_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_system_identifier_state,before_doctype_system_identifier_state))))))))))))

 -> Switch(Before_DOCTYPE_system_identifier_state)

-- chara: U+0020 SPACE --
Switch to the before DOCTYPE system identifier state.
  | you Switch to the Before_DOCTYPE_system_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Before_DOCTYPE_system_identifier_state,before_doctype_system_identifier_state))))))))))))

 -> Switch(Before_DOCTYPE_system_identifier_state)

-- chara: U+0022 QUOTATION MARK (") --
This is a missing-whitespace-after-doctype-system-keyword parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
  | This is a missing_whitespace_after_doctype_system_keyword parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then you switch to the DOCTYPE_system_identifier_double_quoted_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_whitespace_after_doctype_system_keyword,missing_whitespace_after_doctype_system_keyword)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_system_identifier_double_quoted_state,doctype_system_identifier_double_quoted_state))))))))))))

 -> Error(missing_whitespace_after_doctype_system_keyword parse error)
 -> Set(the DOCTYPE token 's system identifier,the empty string)
 -> Switch(DOCTYPE_system_identifier_double_quoted_state)

-- chara: U+0027 APOSTROPHE (') --
This is a missing-whitespace-after-doctype-system-keyword parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
  | This is a missing_whitespace_after_doctype_system_keyword parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then you switch to the DOCTYPE_system_identifier_single_quoted_state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_whitespace_after_doctype_system_keyword,missing_whitespace_after_doctype_system_keyword)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_system_identifier_single_quoted_state,doctype_system_identifier_single_quoted_state))))))))))))

 -> Error(missing_whitespace_after_doctype_system_keyword parse error)
 -> Set(the DOCTYPE token 's system identifier,the empty string)
 -> Switch(DOCTYPE_system_identifier_single_quoted_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is a missing-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
  | This is a missing_doctype_system_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Switch to the Data_state. you Emit that DOCTYPE token.
List(List(), List((10,CHAIN10-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["you" in sentence 3])), List((8,CHAIN8-["you" in sentence 4]), (10,CHAIN10-["that DOCTYPE token" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_doctype_system_identifier,missing_doctype_system_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(10,DOCTYPE,doctype)), Leaf(NN,Token(10,token,token)), Leaf(POS,Token(10,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(10,that,that)), Leaf(JJ,Token(10,DOCTYPE,doctype)), Leaf(NN,Token(10,token,token))))))))))

 -> Error(missing_doctype_system_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Switch(Data_state)
 -> Emit(DOCTYPE token,10)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is a missing-quote-before-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
  | This is a missing_quote_before_doctype_system_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Reconsume in the Bogus_DOCTYPE_state.
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_quote_before_doctype_system_identifier,missing_quote_before_doctype_system_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_DOCTYPE_state,Bogus_DOCTYPE_state))))))))))))

 -> Error(missing_quote_before_doctype_system_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Reconsume(Bogus_DOCTYPE_state)

64 : Before_DOCTYPE_system_identifier_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000A LINE FEED (LF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000C FORM FEED (FF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0020 SPACE --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0022 QUOTATION MARK (") --
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
  | Set the DOCTYPE token's system identifier to the empty string (not missing), then you switch to the DOCTYPE_system_identifier_double_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_system_identifier_double_quoted_state,doctype_system_identifier_double_quoted_state))))))))))))

 -> Set(the DOCTYPE token 's system identifier,the empty string)
 -> Switch(DOCTYPE_system_identifier_double_quoted_state)

-- chara: U+0027 APOSTROPHE (') --
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
  | Set the DOCTYPE token's system identifier to the empty string (not missing), then you switch to the DOCTYPE_system_identifier_single_quoted_state.
List(List())
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string)))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,DOCTYPE_system_identifier_single_quoted_state,doctype_system_identifier_single_quoted_state))))))))))))

 -> Set(the DOCTYPE token 's system identifier,the empty string)
 -> Switch(DOCTYPE_system_identifier_single_quoted_state)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is a missing-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
  | This is a missing_doctype_system_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Switch to the Data_state. you Emit that DOCTYPE token.
List(List(), List((10,CHAIN10-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["you" in sentence 3])), List((8,CHAIN8-["you" in sentence 4]), (10,CHAIN10-["that DOCTYPE token" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_doctype_system_identifier,missing_doctype_system_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(10,DOCTYPE,doctype)), Leaf(NN,Token(10,token,token)), Leaf(POS,Token(10,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(10,that,that)), Leaf(JJ,Token(10,DOCTYPE,doctype)), Leaf(NN,Token(10,token,token))))))))))

 -> Error(missing_doctype_system_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Switch(Data_state)
 -> Emit(DOCTYPE token,10)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is a missing-quote-before-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
  | This is a missing_quote_before_doctype_system_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Reconsume in the Bogus_DOCTYPE_state.
List(List(), List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_quote_before_doctype_system_identifier,missing_quote_before_doctype_system_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_DOCTYPE_state,Bogus_DOCTYPE_state))))))))))))

 -> Error(missing_quote_before_doctype_system_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Reconsume(Bogus_DOCTYPE_state)

65 : DOCTYPE_system_identifier_double_quoted_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0022 QUOTATION MARK (") --
Switch to the after DOCTYPE system identifier state.
  | you Switch to the After_DOCTYPE_system_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_system_identifier_state,after_doctype_system_identifier_state))))))))))))

 -> Switch(After_DOCTYPE_system_identifier_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's system identifier)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is an abrupt-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
  | This is an abrupt_doctype_system_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Switch to the Data_state. you Emit that DOCTYPE token.
List(List(), List((11,CHAIN11-["the DOCTYPE token 's" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4]), (11,CHAIN11-["that DOCTYPE token" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,abrupt_doctype_system_identifier,abrupt_doctype_system_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(11,DOCTYPE,doctype)), Leaf(NN,Token(11,token,token)), Leaf(POS,Token(11,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(11,that,that)), Leaf(JJ,Token(11,DOCTYPE,doctype)), Leaf(NN,Token(11,token,token))))))))))

 -> Error(abrupt_doctype_system_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Switch(Data_state)
 -> Emit(DOCTYPE token,11)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the current DOCTYPE token's system identifier.
  | you Append the current input character to the current DOCTYPE token's system identifier.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier))))))))))))

 -> Append(current input character,the current DOCTYPE token 's system identifier)

66 : DOCTYPE_system_identifier_single_quoted_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0027 APOSTROPHE (') --
Switch to the after DOCTYPE system identifier state.
  | you Switch to the After_DOCTYPE_system_identifier_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,After_DOCTYPE_system_identifier_state,after_doctype_system_identifier_state))))))))))))

 -> Switch(After_DOCTYPE_system_identifier_state)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
  | This is an unexpected_null_character parse error. you Append a U_FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,U_FFFD,U_FFFD)), Node(NML,List(Leaf(NN,Token(-1,REPLACEMENT,REPLACEMENT)), Leaf(NN,Token(-1,CHARACTER,CHARACTER)))), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier))))))))))))

 -> Error(unexpected_null_character parse error)
 -> Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's system identifier)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
This is an abrupt-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
  | This is an abrupt_doctype_system_identifier parse error. Set the DOCTYPE token's force_quirks flag to on. you Switch to the Data_state. you Emit that DOCTYPE token.
List(List(), List((11,CHAIN11-["the DOCTYPE token 's" in sentence 2])), List((9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4]), (11,CHAIN11-["that DOCTYPE token" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,abrupt_doctype_system_identifier,abrupt_doctype_system_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(11,DOCTYPE,doctype)), Leaf(NN,Token(11,token,token)), Leaf(POS,Token(11,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(11,that,that)), Leaf(JJ,Token(11,DOCTYPE,doctype)), Leaf(NN,Token(11,token,token))))))))))

 -> Error(abrupt_doctype_system_identifier parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Switch(Data_state)
 -> Emit(DOCTYPE token,11)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Append the current input character to the current DOCTYPE token's system identifier.
  | you Append the current input character to the current DOCTYPE token's system identifier.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token)), Leaf(POS,Token(-1,'s,'s)))), Leaf(NN,Token(-1,system,system)), Leaf(NN,Token(-1,identifier,identifier))))))))))))

 -> Append(current input character,the current DOCTYPE token 's system identifier)

67 : After_DOCTYPE_system_identifier_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+0009 CHARACTER TABULATION (tab) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000A LINE FEED (LF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+000C FORM FEED (FF) --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+0020 SPACE --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the current DOCTYPE token.
  | you Switch to the Data_state. you Emit the current DOCTYPE token.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(current DOCTYPE token,-1)

-- chara: EOF --
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
  | This is an eof_in_doctype parse error. Set the DOCTYPE token's force_quirks flag to on. you Emit that DOCTYPE token. you Emit an end_of_file token.
List(List(), List((8,CHAIN8-["the DOCTYPE token 's" in sentence 2])), List((8,CHAIN8-["that DOCTYPE token" in sentence 3]), (9,CHAIN9-["you" in sentence 3])), List((9,CHAIN9-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,eof_in_doctype,eof_in_doctype)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,the,the)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token)), Leaf(POS,Token(8,'s,'s)))), Leaf(JJ,Token(-1,force_quirks,force_quirks)), Leaf(NN,Token(-1,flag,flag)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(PP,List(Leaf(IN,Token(-1,on,on))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(8,that,that)), Leaf(JJ,Token(8,DOCTYPE,doctype)), Leaf(NN,Token(8,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_doctype parse error)
 -> Set(the DOCTYPE token 's force_quirks flag,on)
 -> Emit(DOCTYPE token,8)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
This is an unexpected-character-after-doctype-system-identifier parse error. Reconsume in the bogus DOCTYPE state. (This does not set the DOCTYPE token's force-quirks flag to on.)
  | This is an unexpected_character_after_doctype_system_identifier parse error. you Reconsume in the Bogus_DOCTYPE_state. (This does not set the DOCTYPE token's force_quirks flag to on.)
List(List((7,CHAIN7-["This" in sentence 1])), List(), List((7,CHAIN7-["This" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(7,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_character_after_doctype_system_identifier,unexpected_character_after_doctype_system_identifier)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Bogus_DOCTYPE_state,Bogus_DOCTYPE_state))))))))))))
Node(ROOT,List(Node(S,List())))

 -> Error(unexpected_character_after_doctype_system_identifier parse error)
 -> Reconsume(Bogus_DOCTYPE_state)

68 : Bogus_DOCTYPE_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+003E GREATER-THAN SIGN (&gt;) --
Switch to the data state. Emit the DOCTYPE token.
  | you Switch to the Data_state. you Emit the DOCTYPE token.
List(List((5,CHAIN5-["you" in sentence 1])), List((5,CHAIN5-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token))))))))))

 -> Switch(Data_state)
 -> Emit(DOCTYPE token,-1)

-- chara: U+0000 NULL --
This is an unexpected-null-character parse error. Ignore the character.
  | This is an unexpected_null_character parse error. Ignore the character.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unexpected_null_character,unexpected_null_character)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Error(unexpected_null_character parse error)
 -> Ignore(character)

-- chara: EOF --
Emit the DOCTYPE token. Emit an end-of-file token.
  | you Emit the DOCTYPE token. you Emit an end_of_file token.
List(List((5,CHAIN5-["you" in sentence 1])), List((5,CHAIN5-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,DOCTYPE,doctype)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(DOCTYPE token,-1)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Ignore the character.
  | Ignore the character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Ignore,ignore)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character))))))))))

 -> Ignore(character)

69 : CDATA_section_state
Consume the next input character:U+0000 NULL characters are handled in the tree construction stage, as part of the in foreign content insertion mode, which is the only place where CDATA sections can appear.
  | Consume the next input character:U_0000 NULL characters are handled in the tree construction stage, as part of the in foreign content insertion mode, which is the only place where CDATA sections can appear.
List(List())
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Consume,consume)))), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(SYM,Token(-1,:,:)), Node(NP,List(Leaf(CD,Token(-1,U_0000,U_0000)), Leaf(JJ,Token(-1,NULL,NULL)), Leaf(NNS,Token(-1,characters,character)))))))), Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(VP,List(Leaf(VB,Token(-1,handled,handle)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,tree,tree)), Leaf(NN,Token(-1,construction,construction)), Leaf(NN,Token(-1,stage,stage)))))), Leaf(Comma,Token(-1,,,,)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NP,List(Leaf(NN,Token(-1,part,part)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(JJ,Token(-1,foreign,foreign)), Leaf(NN,Token(-1,content,content)))))))), Leaf(NN,Token(-1,insertion,insertion)), Leaf(NN,Token(-1,mode,mode)))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Node(WHNP,List(Leaf(WDT,Token(-1,which,which)))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,only,only)), Leaf(NN,Token(-1,place,place)))), Node(SBAR,List(Node(WHADVP,List(Leaf(WRB,Token(-1,where,where)))), Node(S,List(Node(NP,List(Leaf(NNP,Token(-1,CDATA,cdata)), Leaf(NNS,Token(-1,sections,section)))), Node(VP,List(Leaf(MD,Token(-1,can,can)), Node(VP,List(Leaf(VB,Token(-1,appear,appear))))))))))))))))))))))))))))))))))
### not match_s : List(Node(ADVP,List(Leaf(RB,Token(-1,Consume,consume)))), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(SYM,Token(-1,:,:)), Node(NP,List(Leaf(CD,Token(-1,U_0000,U_0000)), Leaf(JJ,Token(-1,NULL,NULL)), Leaf(NNS,Token(-1,characters,character)))))))), Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(VP,List(Leaf(VB,Token(-1,handled,handle)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,tree,tree)), Leaf(NN,Token(-1,construction,construction)), Leaf(NN,Token(-1,stage,stage)))))), Leaf(Comma,Token(-1,,,,)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NP,List(Leaf(NN,Token(-1,part,part)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Node(NML,List(Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(JJ,Token(-1,foreign,foreign)), Leaf(NN,Token(-1,content,content)))))))), Leaf(NN,Token(-1,insertion,insertion)), Leaf(NN,Token(-1,mode,mode)))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Node(WHNP,List(Leaf(WDT,Token(-1,which,which)))), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,only,only)), Leaf(NN,Token(-1,place,place)))), Node(SBAR,List(Node(WHADVP,List(Leaf(WRB,Token(-1,where,where)))), Node(S,List(Node(NP,List(Leaf(NNP,Token(-1,CDATA,cdata)), Leaf(NNS,Token(-1,sections,section)))), Node(VP,List(Leaf(MD,Token(-1,can,can)), Node(VP,List(Leaf(VB,Token(-1,appear,appear)))))))))))))))))))))))))))))))


-- chara: U+005D RIGHT SQUARE BRACKET (]) --
Switch to the CDATA section bracket state.
  | you Switch to the CDATA_section_bracket_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,CDATA_section_bracket_state,CDATA_section_bracket_state))))))))))))

 -> Switch(CDATA_section_bracket_state)

-- chara: EOF --
This is an eof-in-cdata parse error. Emit an end-of-file token.
  | This is an eof_in_cdata parse error. you Emit an end_of_file token.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(NN,Token(-1,eof_in_cdata,eof_in_cdata)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,end_of_file,end_of_file)), Leaf(NN,Token(-1,token,token))))))))))

 -> Error(eof_in_cdata parse error)
 -> Emit(end_of_file token,-1)

-- chara: Anything else --
Emit the current input character as a character token.
  | you Emit the current input character as a character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> Emit(current input character as a character token,-1)

70 : CDATA_section_bracket_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+005D RIGHT SQUARE BRACKET (]) --
Switch to the CDATA section end state.
  | you Switch to the CDATA_section_end_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,CDATA_section_end_state,CDATA_section_end_state))))))))))))

 -> Switch(CDATA_section_end_state)

-- chara: Anything else --
Emit a U+005D RIGHT SQUARE BRACKET character token. Reconsume in the CDATA section state.
  | you Emit a U_005D RIGHT SQUARE BRACKET character token. you Reconsume in the CDATA_section_state.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_005D,u_005d)), Leaf(NNP,Token(-1,RIGHT,right)), Leaf(NNP,Token(-1,SQUARE,SQUARE)))), Leaf(JJ,Token(-1,BRACKET,BRACKET)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,CDATA_section_state,CDATA_section_state))))))))))))

 -> Emit(U_005D,-1)
 -> Reconsume(CDATA_section_state)

71 : CDATA_section_end_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: U+005D RIGHT SQUARE BRACKET (]) --
Emit a U+005D RIGHT SQUARE BRACKET character token.
  | you Emit a U_005D RIGHT SQUARE BRACKET character token.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_005D,u_005d)), Leaf(NNP,Token(-1,RIGHT,right)), Leaf(NNP,Token(-1,SQUARE,SQUARE)))), Leaf(JJ,Token(-1,BRACKET,BRACKET)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))

 -> Emit(U_005D,-1)

-- chara: U+003E GREATER-THAN SIGN character --
Switch to the data state.
  | you Switch to the Data_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Data_state,Data_state))))))))))))

 -> Switch(Data_state)

-- chara: Anything else --
Emit two U+005D RIGHT SQUARE BRACKET character tokens. Reconsume in the CDATA section state.
  | you Emit two U_005D RIGHT SQUARE BRACKET character tokens. you Reconsume in the CDATA_section_state.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Emit,emit)), Node(NP,List(Leaf(CD,Token(-1,two,two)), Leaf(NNP,Token(-1,U_005D,u_005d)), Node(NML,List(Leaf(NNP,Token(-1,RIGHT,right)), Leaf(NNP,Token(-1,SQUARE,SQUARE)))), Leaf(NN,Token(-1,BRACKET,BRACKET)), Leaf(NN,Token(-1,character,character)), Leaf(NNS,Token(-1,tokens,token))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,CDATA_section_state,CDATA_section_state))))))))))))

 -> Emit(two U_005Ds,-1)
 -> Reconsume(CDATA_section_state)

72 : Character_reference_state
Set the temporary buffer to the empty string. Append a U+0026 AMPERSAND (&amp;) character to the temporary buffer. Consume the next input character:
  | Set the temporary buffer to the empty string. you Append a U_0026 AMPERSAND (&amp;) character to the temporary buffer. Consume the next input character.
List(List((4,CHAIN4-["the temporary buffer" in sentence 1])), List((4,CHAIN4-["the temporary buffer" in sentence 2]), (6,CHAIN6-["a U_0026 AMPERSAND ( & ) character" in sentence 2])), List((6,CHAIN6-["the next input character" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(4,temporary,temporary)), Leaf(NN,Token(4,buffer,buffer)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(6,a,a)), Node(NML,List(Node(NML,List(Leaf(NNP,Token(6,U_0026,u_0026)), Leaf(NNP,Token(6,AMPERSAND,ampersand)))))), Leaf(NN,Token(6,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(4,the,the)), Leaf(JJ,Token(4,temporary,temporary)), Leaf(NN,Token(4,buffer,buffer))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(6,the,the)), Leaf(JJ,Token(6,next,next)), Leaf(NN,Token(6,input,input)), Leaf(NN,Token(6,character,character))))))))))

 -> Set(the temporary buffer,the empty string)
 -> Append(U_0026 AMPERSAND character,the temporary buffer)
 -> Consume(next input character)

-- chara: ASCII alphanumeric --
Reconsume in the named character reference state.
  | you Reconsume in the Named_character_reference_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Named_character_reference_state,named_character_reference_state))))))))))))

 -> Reconsume(Named_character_reference_state)

-- chara: U+0023 NUMBER SIGN (#) --
Append the current input character to the temporary buffer. Switch to the numeric character reference state.
  | you Append the current input character to the temporary buffer. you Switch to the Numeric_character_reference_state.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Numeric_character_reference_state,numeric_character_reference_state))))))))))))

 -> Append(current input character,the temporary buffer)
 -> Switch(Numeric_character_reference_state)

-- chara: Anything else --
Flush code points consumed as a character reference. Reconsume in the return state.
  | you Flush code points consumed as a character reference. you Reconsume in the return state.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Flush,flush)), Node(NP,List(Node(NP,List(Leaf(NN,Token(-1,code,code)), Leaf(NNS,Token(-1,points,point)))), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state))))))))))))

 -> Flush()
 -> Reconsume(return state)

73 : Named_character_reference_state
Consume the maximum number of characters possible, where the consumed characters are one of the identifiers in the first column of the named character references table. Append each character to the temporary buffer when it's consumed.If the markup contains (not in an attribute) the string I'm &amp;notit; I tell you, the character reference is parsed as "not", as in, I'm ¬it; I tell you (and this is a parse error). But if the markup was I'm &amp;notin; I tell you, the character reference would be parsed as "notin;", resulting in I'm ∉ I tell you (and no parse error).However, if the markup contains the string I'm &amp;notit; I tell you in an attribute, no character reference is parsed and string remains intact (and there is no parse error).
  | Consume the maximum number of characters possible, where the consumed characters are one of the identifiers in the first column of the named character references table. you Append each character to the temporary buffer when it's consumed.If the markup contains (not in an attribute) the string I'm &amp;notit; I tell you, the character reference is parsed as "not", as in, I'm ¬it; I tell you (and this is a parse error). But if the markup was I'm &amp;notin; I tell you, the character reference would be parsed as "notin;", resulting in I'm ∉ I tell you (and no parse error).However, if the markup contains the string I'm &amp;notit; I tell you in an attribute, no character reference is parsed and string remains intact (and there is no parse error).
List(List((22,CHAIN22-["the named character references" in sentence 1]), (25,CHAIN25-["the consumed characters" in sentence 1])), List((22,CHAIN22-["the character reference" in sentence 2, "it" in sentence 2]), (39,CHAIN39-["the markup" in sentence 2]), (25,CHAIN25-["this" in sentence 2]), (43,CHAIN43-["I" in sentence 2, "I" in sentence 2, "I" in sentence 2, "I" in sentence 2]), (44,CHAIN44-["you" in sentence 2, "you" in sentence 2, "you" in sentence 2])), List((22,CHAIN22-["the character reference" in sentence 3]), (39,CHAIN39-["the markup" in sentence 3]), (43,CHAIN43-["I" in sentence 3, "I" in sentence 3, "I" in sentence 3, "I" in sentence 3]), (44,CHAIN44-["you" in sentence 3, "you" in sentence 3])), List((39,CHAIN39-["the markup" in sentence 4]), (43,CHAIN43-["I" in sentence 4, "I" in sentence 4]), (44,CHAIN44-["you" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(S,List(Node(NP,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(JJ,Token(-1,maximum,maximum)), Leaf(NN,Token(-1,number,number)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(NNS,Token(25,characters,character)))))))), Node(ADJP,List(Leaf(JJ,Token(-1,possible,possible)))))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Node(WHADVP,List(Leaf(WRB,Token(-1,where,where)))), Node(S,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(CD,Token(25,consumed,consume)), Leaf(NNS,Token(25,characters,character)))), Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(NP,List(Node(NP,List(Leaf(CD,Token(-1,one,one)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(22,the,the)), Node(ADJP,List(Leaf(JJ,Token(-1,identifiers,identifier)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(JJ,Token(-1,first,first)), Leaf(NN,Token(-1,column,column)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(VB,Token(22,named,name)), Leaf(NN,Token(22,character,character)), Leaf(NNS,Token(22,references,reference)))))))))))), Leaf(NN,Token(-1,table,table))))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,each,each)), Leaf(NN,Token(22,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))))), Node(SBAR,List(Node(WHADVP,List(Leaf(WRB,Token(-1,when,when)))), Node(S,List(Node(NP,List(Leaf(PRP,Token(22,it,it)))), Node(VP,List(Leaf(VB,Token(-1,'s,be)), Node(ADJP,List(Leaf(JJ,Token(-1,consumed.If,consumed.if)), Node(SBAR,List(Node(S,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(39,markup,markup)))), Node(VP,List(Leaf(VB,Token(-1,contains,contain)), Node(PP,List()), Node(NP,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(-1,string,string)))), Node(SBAR,List(Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(NP,List(Leaf(CC,Token(-1,&,&)), Leaf(NN,Token(-1,notit,notit)))))))))))))))))))))))))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell)), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Node(S,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(22,character,character)), Leaf(NN,Token(22,reference,reference)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(VP,List(Leaf(VB,Token(-1,parsed,parse)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Leaf(LDoubleQuote,Token(-1,",")), Node(NP,List(Leaf(RB,Token(-1,not,not)))), Leaf(RDoubleQuote,Token(-1,",")))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Leaf(IN,Token(-1,as,as)), Node(S,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,in,in)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(VP,List(Leaf(VB,Token(-1,¬,¬)), Node(NP,List(Leaf(PRP,Token(22,it,it)))))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell))))))))))))))))))))))))))
Node(ROOT,List(Node(S,List(Leaf(CC,Token(-1,But,but)), Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(39,markup,markup)))), Node(VP,List(Leaf(VB,Token(-1,was,be)), Node(S,List(Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(NP,List(Leaf(CC,Token(-1,&,&)), Leaf(NN,Token(-1,notin,notin)))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell)))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(22,character,character)), Leaf(NN,Token(22,reference,reference)))), Node(VP,List(Leaf(MD,Token(-1,would,would)), Node(VP,List(Leaf(VB,Token(-1,be,be)), Node(VP,List(Leaf(VB,Token(-1,parsed,parse)), Node(SBAR,List(Leaf(IN,Token(-1,as,as)), Node(S,List(Node(NP,List(Node(NP,List(Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,notin,notin)), Leaf(Comma,Token(-1,;,;)), Leaf(RDoubleQuote,Token(-1,",")))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,resulting,result)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(PRP,Token(43,I,I)))))))))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(VP,List(Leaf(VB,Token(-1,∉,∉)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell))))))))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,However,however)))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(39,markup,markup)))), Node(VP,List(Leaf(VB,Token(-1,contains,contain)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)))))))))), Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(NP,List(Leaf(CC,Token(-1,&,&)), Leaf(NN,Token(-1,notit,notit)))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(NN,Token(-1,attribute,attribute)))))))))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,no,no)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(ADJP,List(Leaf(JJ,Token(-1,parsed,parsed)))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(NP,List(Leaf(NN,Token(-1,string,string)))), Node(VP,List(Leaf(VB,Token(-1,remains,remain)), Node(FRAG,List(Node(ADJP,List(Leaf(JJ,Token(-1,intact,intact))))))))))))))
### dont match_vp : List(Leaf(VB,Token(-1,Consume,consume)), Node(S,List(Node(NP,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(JJ,Token(-1,maximum,maximum)), Leaf(NN,Token(-1,number,number)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(NNS,Token(25,characters,character)))))))), Node(ADJP,List(Leaf(JJ,Token(-1,possible,possible)))))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Node(WHADVP,List(Leaf(WRB,Token(-1,where,where)))), Node(S,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(CD,Token(25,consumed,consume)), Leaf(NNS,Token(25,characters,character)))), Node(VP,List(Leaf(VB,Token(-1,are,be)), Node(NP,List(Node(NP,List(Leaf(CD,Token(-1,one,one)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(22,the,the)), Node(ADJP,List(Leaf(JJ,Token(-1,identifiers,identifier)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(JJ,Token(-1,first,first)), Leaf(NN,Token(-1,column,column)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(VB,Token(22,named,name)), Leaf(NN,Token(22,character,character)), Leaf(NNS,Token(22,references,reference)))))))))))), Leaf(NN,Token(-1,table,table)))))))))))))))
### not match_s : List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,each,each)), Leaf(NN,Token(22,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))))), Node(SBAR,List(Node(WHADVP,List(Leaf(WRB,Token(-1,when,when)))), Node(S,List(Node(NP,List(Leaf(PRP,Token(22,it,it)))), Node(VP,List(Leaf(VB,Token(-1,'s,be)), Node(ADJP,List(Leaf(JJ,Token(-1,consumed.If,consumed.if)), Node(SBAR,List(Node(S,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(39,markup,markup)))), Node(VP,List(Leaf(VB,Token(-1,contains,contain)), Node(PP,List()), Node(NP,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(-1,string,string)))), Node(SBAR,List(Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(NP,List(Leaf(CC,Token(-1,&,&)), Leaf(NN,Token(-1,notit,notit)))))))))))))))))))))))))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell)), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Node(S,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(22,character,character)), Leaf(NN,Token(22,reference,reference)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(VP,List(Leaf(VB,Token(-1,parsed,parse)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Leaf(LDoubleQuote,Token(-1,",")), Node(NP,List(Leaf(RB,Token(-1,not,not)))), Leaf(RDoubleQuote,Token(-1,",")))), Leaf(Comma,Token(-1,,,,)), Node(SBAR,List(Leaf(IN,Token(-1,as,as)), Node(S,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,in,in)))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(VP,List(Leaf(VB,Token(-1,¬,¬)), Node(NP,List(Leaf(PRP,Token(22,it,it)))))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell)))))))))))))))))))))))
### not match_s : List(Leaf(CC,Token(-1,But,but)), Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(39,markup,markup)))), Node(VP,List(Leaf(VB,Token(-1,was,be)), Node(S,List(Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(NP,List(Leaf(CC,Token(-1,&,&)), Leaf(NN,Token(-1,notin,notin)))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell)))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(NP,List(Leaf(DT,Token(22,the,the)), Leaf(NN,Token(22,character,character)), Leaf(NN,Token(22,reference,reference)))), Node(VP,List(Leaf(MD,Token(-1,would,would)), Node(VP,List(Leaf(VB,Token(-1,be,be)), Node(VP,List(Leaf(VB,Token(-1,parsed,parse)), Node(SBAR,List(Leaf(IN,Token(-1,as,as)), Node(S,List(Node(NP,List(Node(NP,List(Leaf(LDoubleQuote,Token(-1,",")), Leaf(NN,Token(-1,notin,notin)), Leaf(Comma,Token(-1,;,;)), Leaf(RDoubleQuote,Token(-1,",")))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,resulting,result)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(PRP,Token(43,I,I)))))))))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(VP,List(Leaf(VB,Token(-1,∉,∉)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell)))))))))))))))))))))
### not match_s : List(Node(ADVP,List(Leaf(RB,Token(-1,However,however)))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,if,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(39,markup,markup)))), Node(VP,List(Leaf(VB,Token(-1,contains,contain)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,string,string)))))))))), Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,'m,be)), Node(NP,List(Leaf(CC,Token(-1,&,&)), Leaf(NN,Token(-1,notit,notit)))))))), Leaf(Colon,Token(-1,;,;)), Node(S,List(Node(NP,List(Leaf(PRP,Token(43,I,I)))), Node(VP,List(Leaf(VB,Token(-1,tell,tell)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(NN,Token(-1,attribute,attribute)))))))))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(NP,List(Leaf(DT,Token(-1,no,no)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(ADJP,List(Leaf(JJ,Token(-1,parsed,parsed)))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(NP,List(Leaf(NN,Token(-1,string,string)))), Node(VP,List(Leaf(VB,Token(-1,remains,remain)), Node(FRAG,List(Node(ADJP,List(Leaf(JJ,Token(-1,intact,intact)))))))))))


-- chara: If there is a match --
 If the character reference was consumed as part of an attribute, and the last character matched is not a U+003B SEMICOLON character (;), and the next input character is either a U+003D EQUALS SIGN character (=) or an ASCII alphanumeric, then, for historical reasons, flush code points consumed as a character reference and switch to the return state.  Otherwise: If the last character matched is not a U+003B SEMICOLON character (;), then this is a missing-semicolon-after-character-reference parse error.Set the temporary buffer to the empty string. Append one or two characters corresponding to the character reference name (as given by the second column of the named character references table) to the temporary buffer.Flush code points consumed as a character reference. Switch to the return state. 
  |  If the character reference was consumed as part of an attribute, and the last character matched is not a U_003B SEMICOLON character (;), and the next input character is either a U_003D EQUALS SIGN character (=) or an ASCII alphanumeric, then, for historical reasons, you flush code points consumed as a character reference and you switch to the return state.  Otherwise: If the last character matched is not a U_003B SEMICOLON character (;), then this is a missing_semicolon_after_character_reference parse error.Set the temporary buffer to the empty string. you Append one or two characters corresponding to the character reference name (as given by the second column of the named character references table) to the temporary buffer.you Flush code points consumed as a character reference. you Switch to the return state. 
List(List((16,CHAIN16-["the last character matched" in sentence 1, "the next input character" in sentence 1]), (37,CHAIN37-["the return state" in sentence 1]), (14,CHAIN14-["you" in sentence 1, "you" in sentence 1])), List((16,CHAIN16-["the last character matched is not a U_003B SEMICOLON character ( ;) , then this" in sentence 2])), List((36,CHAIN36-["you" in sentence 3])), List((36,CHAIN36-["you" in sentence 4]), (37,CHAIN37-["the return state" in sentence 4])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(S,List(Node(NP,List(Leaf(DT,Token(37,the,the)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)))), Node(VP,List(Leaf(VB,Token(-1,was,be)), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NP,List(Leaf(NN,Token(-1,part,part)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(NN,Token(-1,attribute,attribute)))))))))))))))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(S,List(Node(NP,List(Node(NP,List(Leaf(DT,Token(37,the,the)), Leaf(JJ,Token(16,last,last)), Leaf(NN,Token(-1,character,character)))), Node(VP,List(Leaf(VB,Token(16,matched,match)))))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Leaf(RB,Token(-1,not,not)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003B,u_003b)), Leaf(NNP,Token(-1,SEMICOLON,semicolon)))), Leaf(NN,Token(-1,character,character)))), Leaf(LBracket,Token(-1,(,()), Node(NP,List(Leaf(NNP,Token(-1,;),;))))))))))), Leaf(Comma,Token(-1,,,,)), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(NP,List(Leaf(DT,Token(37,the,the)), Leaf(JJ,Token(16,next,next)), Leaf(NN,Token(16,input,input)), Leaf(NN,Token(-1,character,character)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(CC,Token(-1,either,either)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Node(NML,List(Leaf(NNP,Token(-1,U_003D,u_003d)), Leaf(NNP,Token(-1,EQUALS,equal)), Leaf(NNP,Token(-1,SIGN,SIGN)))), Leaf(NN,Token(-1,character,character)))), Leaf(LBracket,Token(-1,(,()), Node(NP,List(Node(NP,List(Leaf(NNP,Token(-1,=),=))))), Leaf(CC,Token(-1,or,or)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(VB,Token(-1,ASCII,ASCII)), Leaf(NN,Token(-1,alphanumeric,alphanumeric)))))))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Leaf(Comma,Token(-1,,,,)), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Leaf(JJ,Token(-1,historical,historical)), Leaf(NNS,Token(-1,reasons,reason)))))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,flush,flush)), Node(S,List(Node(NP,List(Leaf(NN,Token(-1,code,code)), Leaf(NNS,Token(-1,points,point)))), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)))))))))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(37,the,the)), Leaf(NN,Token(37,return,return)), Leaf(NN,Token(37,state,state))))))))))))))
Node(ROOT,List(Node(FRAG,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Colon,Token(-1,:,:)), Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(16,last,last)), Leaf(NN,Token(16,character,character)))), Node(VP,List(Leaf(VB,Token(16,matched,match)), Node(S,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,is,be)), Leaf(RB,Token(16,not,not)))), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NNP,Token(16,U_003B,u_003b)), Leaf(NNP,Token(16,SEMICOLON,semicolon)), Leaf(NN,Token(16,character,character)))), Leaf(LBracket,Token(16,(,()), Leaf(NFP,Token(16,;),;))))), Leaf(Comma,Token(16,,,,)), Node(S,List(Node(ADVP,List(Leaf(RB,Token(16,then,then)))), Node(NP,List(Leaf(DT,Token(16,this,this)))))))))))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_semicolon_after_character_reference,missing_semicolon_after_character_reference)), Leaf(NN,Token(-1,parse,parse)))))))))), Node(VP,List(Leaf(VB,Token(-1,error.Set,error.Set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,empty,empty)), Leaf(NN,Token(-1,string,string))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Node(QP,List(Leaf(CD,Token(-1,one,one)), Leaf(CC,Token(-1,or,or)), Leaf(CD,Token(-1,two,two)))), Leaf(NNS,Token(-1,characters,character)))), Node(VP,List(Leaf(VB,Token(-1,corresponding,correspond)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)), Leaf(NN,Token(-1,name,name)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Node(ADJP,List(Node(NP,List(Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer.you,buffer.you)))), Leaf(JJ,Token(-1,Flush,flush)))), Leaf(NN,Token(-1,code,code)), Leaf(NNS,Token(-1,points,point)))), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference))))))))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(37,the,the)), Leaf(NN,Token(37,return,return)), Leaf(NN,Token(37,state,state))))))))))))
### not match_s : List(Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Leaf(Comma,Token(-1,,,,)), Node(PP,List(Leaf(IN,Token(-1,for,for)), Node(NP,List(Leaf(JJ,Token(-1,historical,historical)), Leaf(NNS,Token(-1,reasons,reason)))))), Leaf(Comma,Token(-1,,,,)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,flush,flush)), Node(S,List(Node(NP,List(Leaf(NN,Token(-1,code,code)), Leaf(NNS,Token(-1,points,point)))), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)))))))))))))), Leaf(CC,Token(-1,and,and)), Node(S,List(Node(VP,List(Leaf(VB,Token(-1,switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(37,the,the)), Leaf(NN,Token(37,return,return)), Leaf(NN,Token(37,state,state)))))))))))
### error_root
### dont match_vp : List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Node(NP,List(Node(QP,List(Leaf(CD,Token(-1,one,one)), Leaf(CC,Token(-1,or,or)), Leaf(CD,Token(-1,two,two)))), Leaf(NNS,Token(-1,characters,character)))), Node(VP,List(Leaf(VB,Token(-1,corresponding,correspond)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)), Leaf(NN,Token(-1,name,name)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,the,the)), Node(ADJP,List(Node(NP,List(Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer.you,buffer.you)))), Leaf(JJ,Token(-1,Flush,flush)))), Leaf(NN,Token(-1,code,code)), Leaf(NNS,Token(-1,points,point)))), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)))))))))))))))))

 -> If(UNDEF(the character reference was consumed as part of an attribute , and the last character matched is not a U_003B SEMICOLON character ( ;) , and the next input character is either a U_003D EQUALS SIGN character ( =) or an ASCII alphanumeric),List(Switch(return state)),List())

-- chara: Otherwise --
Flush code points consumed as a character reference. Switch to the ambiguous ampersand state.
  | you Flush code points consumed as a character reference. you Switch to the Ambiguous_ampersand_state.
List(List((4,CHAIN4-["you" in sentence 1])), List((4,CHAIN4-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Flush,flush)), Node(NP,List(Node(NP,List(Leaf(NN,Token(-1,code,code)), Leaf(NNS,Token(-1,points,point)))), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Ambiguous_ampersand_state,ambiguous_ampersand_state))))))))))))

 -> Flush()
 -> Switch(Ambiguous_ampersand_state)

74 : Ambiguous_ampersand_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII alphanumeric --
If the character reference was consumed as part of an attribute, then append the current input character to the current attribute's value. Otherwise, emit the current input character as a character token.
  | If the character reference was consumed as part of an attribute, then you append the current input character to the current attribute's value. Otherwise, you emit the current input character as a character token.
List(List((7,CHAIN7-["an attribute" in sentence 1, "the current attribute 's" in sentence 1]), (10,CHAIN10-["you" in sentence 1]), (11,CHAIN11-["the current input character" in sentence 1])), List((10,CHAIN10-["you" in sentence 2]), (11,CHAIN11-["the current input character" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(SBAR,List(Leaf(IN,Token(-1,If,if)), Node(S,List(Node(NP,List(Leaf(DT,Token(7,the,the)), Leaf(NN,Token(11,character,character)), Leaf(NN,Token(-1,reference,reference)))), Node(VP,List(Leaf(VB,Token(-1,was,be)), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Node(NP,List(Leaf(NN,Token(-1,part,part)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(7,an,a)), Leaf(NN,Token(7,attribute,attribute)))))))))))))))))), Leaf(Comma,Token(-1,,,,)), Node(ADVP,List(Leaf(RB,Token(-1,then,then)))), Node(VP,List(Leaf(VB,Token(-1,append,append)), Node(NP,List(Leaf(DT,Token(7,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(11,input,input)), Leaf(NN,Token(11,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Node(NP,List(Leaf(DT,Token(7,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,attribute,attribute)), Leaf(POS,Token(7,'s,'s)))), Leaf(NN,Token(-1,value,value))))))))))))
Node(ROOT,List(Node(S,List(Node(ADVP,List(Leaf(RB,Token(-1,Otherwise,otherwise)))), Leaf(Comma,Token(-1,,,,)), Node(VP,List(Leaf(VB,Token(-1,emit,emit)), Node(NP,List(Leaf(DT,Token(11,the,the)), Leaf(JJ,Token(11,current,current)), Leaf(NN,Token(11,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,token,token))))))))))))

 -> If(UNDEF(the character reference was consumed as part of an attribute),List(Append(current input character,the current attribute 's value)),List(Emit(current input character as a character token,11)))

-- chara: U+003B SEMICOLON (;) --
This is an unknown-named-character-reference parse error. Reconsume in the return state. 
  | This is an unknown_named_character_reference parse error. you Reconsume in the return state. 
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,unknown_named_character_reference,unknown_named_character_reference)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state))))))))))))

 -> Error(unknown_named_character_reference parse error)
 -> Reconsume(return state)

-- chara: Anything else --
Reconsume in the return state.
  | you Reconsume in the return state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state))))))))))))

 -> Reconsume(return state)

75 : Numeric_character_reference_state
Set the character reference code to zero (0).Consume the next input character:
  | Set the character reference code to zero (0).Consume the next input character.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Set,set)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)), Leaf(NN,Token(-1,code,code)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(CD,Token(-1,zero,zero))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Set(the character reference code,zero)
 -> Consume(next input character)

-- chara: U+0078 LATIN SMALL LETTER X --
Append the current input character to the temporary buffer. Switch to the hexadecimal character reference start state.
  | you Append the current input character to the temporary buffer. you Switch to the Hexadecimal_character_reference_start_state.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Hexadecimal_character_reference_start_state,hexadecimal_character_reference_start_state))))))))))))

 -> Append(current input character,the temporary buffer)
 -> Switch(Hexadecimal_character_reference_start_state)

-- chara: U+0058 LATIN CAPITAL LETTER X --
Append the current input character to the temporary buffer. Switch to the hexadecimal character reference start state.
  | you Append the current input character to the temporary buffer. you Switch to the Hexadecimal_character_reference_start_state.
List(List((6,CHAIN6-["you" in sentence 1])), List((6,CHAIN6-["you" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Append,append)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,current,current)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character)))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,temporary,temporary)), Leaf(NN,Token(-1,buffer,buffer))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Hexadecimal_character_reference_start_state,hexadecimal_character_reference_start_state))))))))))))

 -> Append(current input character,the temporary buffer)
 -> Switch(Hexadecimal_character_reference_start_state)

-- chara: Anything else --
Reconsume in the decimal character reference start state.
  | you Reconsume in the Decimal_character_reference_start_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Decimal_character_reference_start_state,decimal_character_reference_start_state))))))))))))

 -> Reconsume(Decimal_character_reference_start_state)

76 : Hexadecimal_character_reference_start_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII hex digit --
Reconsume in the hexadecimal character reference state.
  | you Reconsume in the Hexadecimal_character_reference_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Hexadecimal_character_reference_state,hexadecimal_character_reference_state))))))))))))

 -> Reconsume(Hexadecimal_character_reference_state)

-- chara: Anything else --
This is an absence-of-digits-in-numeric-character-reference parse error. Flush code points consumed as a character reference. Reconsume in the return state.
  | This is an absence_of_digits_in_numeric_character_reference parse error. you Flush code points consumed as a character reference. you Reconsume in the return state.
List(List(), List((7,CHAIN7-["you" in sentence 2])), List((7,CHAIN7-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,absence_of_digits_in_numeric_character_reference,absence_of_digits_in_numeric_character_reference)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Flush,flush)), Node(NP,List(Node(NP,List(Leaf(NN,Token(-1,code,code)), Leaf(NNS,Token(-1,points,point)))), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state))))))))))))

 -> Error(absence_of_digits_in_numeric_character_reference parse error)
 -> Flush()
 -> Reconsume(return state)

77 : Decimal_character_reference_start_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII digit --
Reconsume in the decimal character reference state.
  | you Reconsume in the Decimal_character_reference_state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NNP,Token(-1,Decimal_character_reference_state,decimal_character_reference_state))))))))))))

 -> Reconsume(Decimal_character_reference_state)

-- chara: Anything else --
This is an absence-of-digits-in-numeric-character-reference parse error. Flush code points consumed as a character reference. Reconsume in the return state.
  | This is an absence_of_digits_in_numeric_character_reference parse error. you Flush code points consumed as a character reference. you Reconsume in the return state.
List(List(), List((7,CHAIN7-["you" in sentence 2])), List((7,CHAIN7-["you" in sentence 3])))
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,an,a)), Leaf(JJ,Token(-1,absence_of_digits_in_numeric_character_reference,absence_of_digits_in_numeric_character_reference)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Flush,flush)), Node(NP,List(Node(NP,List(Leaf(NN,Token(-1,code,code)), Leaf(NNS,Token(-1,points,point)))), Node(VP,List(Leaf(VB,Token(-1,consumed,consume)), Node(PP,List(Leaf(IN,Token(-1,as,as)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference))))))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(NN,Token(-1,return,return)), Leaf(NN,Token(-1,state,state))))))))))))

 -> Error(absence_of_digits_in_numeric_character_reference parse error)
 -> Flush()
 -> Reconsume(return state)

78 : Hexadecimal_character_reference_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII digit --
Multiply the character reference code by 16. Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
  | multiply the character reference code by 16. you Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
List(List((9,CHAIN9-["the character reference code" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2, "the character 's" in sentence 2]), (9,CHAIN9-["the character reference code" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,multiply,multiply)), Node(NP,List(Leaf(DT,Token(9,the,the)), Leaf(NN,Token(9,character,character)), Leaf(NN,Token(9,reference,reference)), Leaf(NN,Token(9,code,code)))), Node(PP,List(Leaf(IN,Token(-1,by,by)), Node(NP,List(Leaf(CD,Token(-1,16,16))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Add,add)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,numeric,numeric)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(9,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(9,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(9,the,the)), Leaf(NN,Token(9,character,character)), Leaf(NN,Token(9,reference,reference)), Leaf(NN,Token(9,code,code))))))))))))

 -> Multiply(character reference code,16)
 -> Add(a numeric version of the current input character,the character reference code)

-- chara: ASCII upper hex digit --
Multiply the character reference code by 16. Add a numeric version of the current input character as a hexadecimal digit (subtract 0x0037 from the character's code point) to the character reference code.
  | multiply the character reference code by 16. you Add a numeric version of the current input character as a hexadecimal digit (subtract 0x0037 from the character's code point) to the character reference code.
List(List((10,CHAIN10-["the character reference code" in sentence 1])), List((8,CHAIN8-["the current input character as a hexadecimal digit" in sentence 2, "the character 's" in sentence 2]), (10,CHAIN10-["the character reference code" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,multiply,multiply)), Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(NN,Token(10,character,character)), Leaf(NN,Token(10,reference,reference)), Leaf(NN,Token(10,code,code)))), Node(PP,List(Leaf(IN,Token(-1,by,by)), Node(NP,List(Leaf(CD,Token(-1,16,16))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Add,add)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,a,a)), Leaf(JJ,Token(-1,numeric,numeric)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(8,input,input)), Leaf(NN,Token(10,character,character)))), Node(PP,List(Leaf(IN,Token(8,as,as)), Node(NP,List(Leaf(DT,Token(8,a,a)), Leaf(JJ,Token(8,hexadecimal,hexadecimal)), Leaf(NN,Token(8,digit,digit)))))))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(NN,Token(10,character,character)), Leaf(NN,Token(10,reference,reference)), Leaf(NN,Token(10,code,code))))))))))))

 -> Multiply(character reference code,16)
 -> Add(a numeric version of the current input character as a hexadecimal digit,the character reference code)

-- chara: ASCII lower hex digit --
Multiply the character reference code by 16. Add a numeric version of the current input character as a hexadecimal digit (subtract 0x0057 from the character's code point) to the character reference code.
  | multiply the character reference code by 16. you Add a numeric version of the current input character as a hexadecimal digit (subtract 0x0057 from the character's code point) to the character reference code.
List(List((10,CHAIN10-["the character reference code" in sentence 1])), List((8,CHAIN8-["the current input character as a hexadecimal digit" in sentence 2, "the character 's" in sentence 2]), (10,CHAIN10-["the character reference code" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,multiply,multiply)), Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(NN,Token(10,character,character)), Leaf(NN,Token(10,reference,reference)), Leaf(NN,Token(10,code,code)))), Node(PP,List(Leaf(IN,Token(-1,by,by)), Node(NP,List(Leaf(CD,Token(-1,16,16))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Add,add)), Node(NP,List(Node(NP,List(Leaf(DT,Token(8,a,a)), Leaf(JJ,Token(-1,numeric,numeric)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(JJ,Token(8,current,current)), Leaf(NN,Token(8,input,input)), Leaf(NN,Token(10,character,character)))), Node(PP,List(Leaf(IN,Token(8,as,as)), Node(NP,List(Leaf(DT,Token(8,a,a)), Leaf(JJ,Token(8,hexadecimal,hexadecimal)), Leaf(NN,Token(8,digit,digit)))))))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(10,the,the)), Leaf(NN,Token(10,character,character)), Leaf(NN,Token(10,reference,reference)), Leaf(NN,Token(10,code,code))))))))))))

 -> Multiply(character reference code,16)
 -> Add(a numeric version of the current input character as a hexadecimal digit,the character reference code)

-- chara: U+003B SEMICOLON --
Switch to the numeric character reference end state.
  | you Switch to the numeric character reference end state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,numeric,numeric)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,state,state))))))))))))

 -> Switch(numeric character reference end state)

-- chara: Anything else --
This is a missing-semicolon-after-character-reference parse error. Reconsume in the numeric character reference end state.
  | This is a missing_semicolon_after_character_reference parse error. you Reconsume in the numeric character reference end state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_semicolon_after_character_reference,missing_semicolon_after_character_reference)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,numeric,numeric)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,state,state))))))))))))

 -> Error(missing_semicolon_after_character_reference parse error)
 -> Reconsume(numeric character reference end state)

79 : Decimal_character_reference_state
Consume the next input character:
  | Consume the next input character.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Consume,consume)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,next,next)), Leaf(NN,Token(-1,input,input)), Leaf(NN,Token(-1,character,character))))))))))

 -> Consume(next input character)

-- chara: ASCII digit --
Multiply the character reference code by 10. Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
  | multiply the character reference code by 10. you Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
List(List((9,CHAIN9-["the character reference code" in sentence 1])), List((7,CHAIN7-["the current input character" in sentence 2, "the character 's" in sentence 2]), (9,CHAIN9-["the character reference code" in sentence 2])))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,multiply,multiply)), Node(NP,List(Leaf(DT,Token(9,the,the)), Leaf(NN,Token(9,character,character)), Leaf(NN,Token(9,reference,reference)), Leaf(NN,Token(9,code,code)))), Node(PP,List(Leaf(IN,Token(-1,by,by)), Node(NP,List(Leaf(CD,Token(-1,10,10))))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Add,add)), Node(NP,List(Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,numeric,numeric)), Leaf(NN,Token(-1,version,version)))), Node(PP,List(Leaf(IN,Token(-1,of,of)), Node(NP,List(Leaf(DT,Token(9,the,the)), Leaf(JJ,Token(7,current,current)), Leaf(NN,Token(7,input,input)), Leaf(NN,Token(9,character,character)))))))), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(9,the,the)), Leaf(NN,Token(9,character,character)), Leaf(NN,Token(9,reference,reference)), Leaf(NN,Token(9,code,code))))))))))))

 -> Multiply(character reference code,10)
 -> Add(a numeric version of the current input character,the character reference code)

-- chara: U+003B SEMICOLON --
Switch to the numeric character reference end state.
  | you Switch to the numeric character reference end state.
List(List())
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Switch,switch)), Node(PP,List(Leaf(IN,Token(-1,to,to)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,numeric,numeric)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,state,state))))))))))))

 -> Switch(numeric character reference end state)

-- chara: Anything else --
This is a missing-semicolon-after-character-reference parse error. Reconsume in the numeric character reference end state.
  | This is a missing_semicolon_after_character_reference parse error. you Reconsume in the numeric character reference end state.
List(List(), List())
Node(ROOT,List(Node(S,List(Node(NP,List(Leaf(DT,Token(-1,This,this)))), Node(VP,List(Leaf(VB,Token(-1,is,be)), Node(NP,List(Leaf(DT,Token(-1,a,a)), Leaf(JJ,Token(-1,missing_semicolon_after_character_reference,missing_semicolon_after_character_reference)), Leaf(NN,Token(-1,parse,parse)), Leaf(NN,Token(-1,error,error))))))))))
Node(ROOT,List(Node(S,List(Node(VP,List(Leaf(VB,Token(-1,Reconsume,reconsume)), Node(PP,List(Leaf(IN,Token(-1,in,in)), Node(NP,List(Leaf(DT,Token(-1,the,the)), Leaf(JJ,Token(-1,numeric,numeric)), Leaf(NN,Token(-1,character,character)), Leaf(NN,Token(-1,reference,reference)), Leaf(NN,Token(-1,end,end)), Leaf(NN,Token(-1,state,state))))))))))))

 -> Error(missing_semicolon_after_character_reference parse error)
 -> Reconsume(numeric character reference end state)

ListMap(Data_state -> pState(Data_state,List(Consume(next input character)),List((U+0026 AMPERSAND (&amp;),List(Set(the return state,the Data_state), Switch(Character_reference_state))), (U+003C LESS-THAN SIGN (&lt;),List(Switch(Tag_open_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Emit(current input character as a character token,-1))), (EOF,List(Emit(end_of_file token,-1))), (Anything else,List(Emit(current input character as a character token,-1))))), RCDATA_state -> pState(RCDATA_state,List(Consume(next input character)),List((U+0026 AMPERSAND (&amp;),List(Set(the return state,the RCDATA_state), Switch(Character_reference_state))), (U+003C LESS-THAN SIGN (&lt;),List(Switch(RCDATA_less_than_sign_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Emit(U_FFFD,-1))), (EOF,List(Emit(end_of_file token,-1))), (Anything else,List(Emit(current input character as a character token,-1))))), RAWTEXT_state -> pState(RAWTEXT_state,List(Consume(next input character)),List((U+003C LESS-THAN SIGN (&lt;),List(Switch(RAWTEXT_less_than_sign_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Emit(U_FFFD,-1))), (EOF,List(Emit(end_of_file token,-1))), (Anything else,List(Emit(current input character as a character token,-1))))), Script_data_state -> pState(Script_data_state,List(Consume(next input character)),List((U+003C LESS-THAN SIGN (&lt;),List(Switch(Script_data_less_than_sign_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Emit(U_FFFD,-1))), (EOF,List(Emit(end_of_file token,-1))), (Anything else,List(Emit(current input character as a character token,-1))))), PLAINTEXT_state -> pState(PLAINTEXT_state,List(Consume(next input character)),List((U+0000 NULL,List(Error(unexpected_null_character parse error), Emit(U_FFFD,-1))), (EOF,List(Emit(end_of_file token,-1))), (Anything else,List(Emit(current input character as a character token,-1))))), Tag_open_state -> pState(Tag_open_state,List(Consume(next input character)),List((U+0021 EXCLAMATION MARK (!),List(Switch(Markup_declaration_open_state))), (U+002F SOLIDUS (/),List(Switch(End_tag_open_state))), (ASCII alpha,List(Create(new start tag token,1), Set(its tag name,the empty string), Reconsume(Tag_name_state))), (U+003F QUESTION MARK (?),List(Error(unexpected_question_mark_instead_of_tag_name parse error), Create(a comment token whose data is the empty string,-1), Reconsume(Bogus_comment_state))), (EOF,List(Error(eof_before_tag_name parse error), Emit(U_003C,-1), Emit(an end_of_file token,-1))), (Anything else,List(Error(invalid_first_character_of_tag_name parse error), Emit(U_003C,-1), Reconsume(Data_state))))), End_tag_open_state -> pState(End_tag_open_state,List(Consume(next input character)),List((ASCII alpha,List(Create(new end tag token,1), Set(its tag name,the empty string), Reconsume(Tag_name_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(missing_end_tag_name parse error), Switch(Data_state))), (EOF,List(Error(eof_before_tag_name parse error), Emit(U_003C,-1), Emit(U_002F,-1), Emit(an end_of_file token,-1))), (Anything else,List(Error(invalid_first_character_of_tag_name parse error), Create(a comment token whose data is the empty string,-1), Reconsume(Bogus_comment_state))))), Tag_name_state -> pState(Tag_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Switch(Before_attribute_name_state))), (U+000A LINE FEED (LF),List(Switch(Before_attribute_name_state))), (U+000C FORM FEED (FF),List(Switch(Before_attribute_name_state))), (U+0020 SPACE,List(Switch(Before_attribute_name_state))), (U+002F SOLIDUS (/),List(Switch(Self_closing_start_tag_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(current tag token,-1))), (ASCII upper alpha,List(Append(the lowercase version of the current input character,the current tag token 's tag name))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current tag token 's tag name))), (EOF,List(Error(eof_in_tag parse error), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the current tag token 's tag name))))), RCDATA_less_than_sign_state -> pState(RCDATA_less_than_sign_state,List(Consume(next input character)),List((U+002F SOLIDUS (/),List(Set(the temporary buffer,the empty string), Switch(RCDATA_end_tag_open_state))), (Anything else,List(Emit(U_003C,-1), Reconsume(RCDATA_state))))), RCDATA_end_tag_open_state -> pState(RCDATA_end_tag_open_state,List(Consume(next input character)),List((ASCII alpha,List(Create(new end tag token,1), Set(its tag name,the empty string), Reconsume(RCDATA_end_tag_name_state))), (Anything else,List(Emit(U_003C,-1), Emit(a U_002F,-1), Reconsume(RCDATA_state))))), RCDATA_end_tag_name_state -> pState(RCDATA_end_tag_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+000A LINE FEED (LF),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+000C FORM FEED (FF),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+0020 SPACE,List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+002F SOLIDUS (/),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Self_closing_start_tag_state)),List(Treat())))), (U+003E GREATER-THAN SIGN (&gt;),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Data_state), Emit(current tag token,8)),List(Treat())))), (ASCII upper alpha,List(Append(the lowercase version of the current input character,the current tag token 's tag name), Append(current input character,the temporary buffer))), (ASCII lower alpha,List(Append(current input character,the current tag token 's tag name), Append(current input character,the temporary buffer))), (Anything else,List(Emit(U_003C,-1), Emit(U_002F,-1), Emit(a character token for each of the characters in the temporary buffer,-1), Reconsume(RCDATA_state))))), RAWTEXT_less_than_sign_state -> pState(RAWTEXT_less_than_sign_state,List(Consume(next input character)),List((U+002F SOLIDUS (/),List(Set(the temporary buffer,the empty string), Switch(RAWTEXT_end_tag_open_state))), (Anything else,List(Emit(U_003C,-1), Reconsume(RAWTEXT_state))))), RAWTEXT_end_tag_open_state -> pState(RAWTEXT_end_tag_open_state,List(Consume(next input character)),List((ASCII alpha,List(Create(new end tag token,1), Set(its tag name,the empty string), Reconsume(RAWTEXT_end_tag_name_state))), (Anything else,List(Emit(UP003C LESS_THAN SIGN character token,-1), Emit(a UP002F SOLIDUS character token,-1), Reconsume(RAWTEXT_state))))), RAWTEXT_end_tag_name_state -> pState(RAWTEXT_end_tag_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+000A LINE FEED (LF),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+000C FORM FEED (FF),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+0020 SPACE,List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+002F SOLIDUS (/),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Self_closing_start_tag_state)),List(Treat())))), (U+003E GREATER-THAN SIGN (&gt;),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Data_state), Emit(current tag token,8)),List(Treat())))), (ASCII upper alpha,List(Append(the lowercase version of the current input character,the current tag token 's tag name), Append(current input character,the temporary buffer))), (ASCII lower alpha,List(Append(current input character,the current tag token 's tag name), Append(current input character,the temporary buffer))), (Anything else,List(Emit(U_003C,-1), Emit(U_002F,-1), Emit(a character token for each of the characters in the temporary buffer,-1), Reconsume(RAWTEXT_state))))), Script_data_less_than_sign_state -> pState(Script_data_less_than_sign_state,List(Consume(next input character)),List((U+002F SOLIDUS (/),List(Set(the temporary buffer,the empty string), Switch(Script_data_end_tag_open_state))), (U+0021 EXCLAMATION MARK (!),List(Switch(Script_data_escape_start_state), Emit(U_003C,-1), Emit(a U_0021,-1))), (Anything else,List(Emit(U_003C,-1), Reconsume(Script_data_state))))), Script_data_end_tag_open_state -> pState(Script_data_end_tag_open_state,List(Consume(next input character)),List((ASCII alpha,List(Create(new end tag token,1), Set(its tag name,the empty string), Reconsume(Script_data_end_tag_name_state))), (Anything else,List(Emit(U_003C,-1), Emit(a U_002F,-1), Reconsume(Script_data_state))))), Script_data_end_tag_name_state -> pState(Script_data_end_tag_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+000A LINE FEED (LF),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+000C FORM FEED (FF),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+0020 SPACE,List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+002F SOLIDUS (/),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Self_closing_start_tag_state)),List(Treat())))), (U+003E GREATER-THAN SIGN (&gt;),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Data_state), Emit(current tag token,8)),List(Treat())))), (ASCII upper alpha,List(Append(the lowercase version of the current input character,the current tag token 's tag name), Append(current input character,the temporary buffer))), (ASCII lower alpha,List(Append(current input character,the current tag token 's tag name), Append(current input character,the temporary buffer))), (Anything else,List(Emit(U_003C,-1), Emit(U_002F,-1), Emit(a character token for each of the characters in the temporary buffer,-1), Reconsume(Script_data_state))))), Script_data_escape_start_state -> pState(Script_data_escape_start_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Script_data_escape_start_dash_state), Emit(U_002D,-1))), (Anything else,List(Reconsume(Script_data_state))))), Script_data_escape_start_dash_state -> pState(Script_data_escape_start_dash_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Script_data_escaped_dash_dash_state), Emit(U_002D,-1))), (Anything else,List(Reconsume(Script_data_state))))), Script_data_escaped_state -> pState(Script_data_escaped_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Script_data_escaped_dash_state), Emit(U_002D,-1))), (U+003C LESS-THAN SIGN (&lt;),List(Switch(Script_data_escaped_less_than_sign_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Emit(U_FFFD,-1))), (EOF,List(Error(eof_in_script_html_comment_like_text parse error), Emit(end_of_file token,-1))), (Anything else,List(Emit(current input character as a character token,-1))))), Script_data_escaped_dash_state -> pState(Script_data_escaped_dash_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Script_data_escaped_dash_dash_state), Emit(U_002D,-1))), (U+003C LESS-THAN SIGN (&lt;),List(Switch(Script_data_escaped_less_than_sign_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Switch(Script_data_escaped_state), Emit(U_FFFD,-1))), (EOF,List(Error(eof_in_script_html_comment_like_text parse error), Emit(end_of_file token,-1))), (Anything else,List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1))))), Script_data_escaped_dash_dash_state -> pState(Script_data_escaped_dash_dash_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Emit(U_002D,-1))), (U+003C LESS-THAN SIGN (&lt;),List(Switch(Script_data_escaped_less_than_sign_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Script_data_state), Emit(U_003E,-1))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Switch(Script_data_escaped_state), Emit(U_FFFD,-1))), (EOF,List(Error(eof_in_script_html_comment_like_text parse error), Emit(end_of_file token,-1))), (Anything else,List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1))))), Script_data_escaped_less_than_sign_state -> pState(Script_data_escaped_less_than_sign_state,List(Consume(next input character)),List((U+002F SOLIDUS (/),List(Set(the temporary buffer,the empty string), Switch(Script_data_escaped_end_tag_open_state))), (ASCII alpha,List(Set(the temporary buffer,the empty string), Emit(U_003C,-1), Reconsume(Script_data_double_escape_start_state))), (Anything else,List(Emit(U_003C,-1), Reconsume(Script_data_escaped_state))))), Script_data_escaped_end_tag_open_state -> pState(Script_data_escaped_end_tag_open_state,List(Consume(next input character)),List((ASCII alpha,List(Create(new end tag token,1), Set(its tag name,the empty string), Reconsume(Script_data_escaped_end_tag_name_state))), (Anything else,List(Emit(U_003C,-1), Emit(a U_002F,-1), Reconsume(Script_data_escaped_state))))), Script_data_escaped_end_tag_name_state -> pState(Script_data_escaped_end_tag_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+000A LINE FEED (LF),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+000C FORM FEED (FF),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+0020 SPACE,List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Before_attribute_name_state)),List(Treat())))), (U+002F SOLIDUS (/),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Self_closing_start_tag_state)),List(Treat())))), (U+003E GREATER-THAN SIGN (&gt;),List(If(IsEqual(the current end tag token,an appropriate end tag token),List(Switch(Data_state), Emit(current tag token,8)),List(Treat())))), (ASCII upper alpha,List(Append(the lowercase version of the current input character,the current tag token 's tag name), Append(current input character,the temporary buffer))), (ASCII lower alpha,List(Append(current input character,the current tag token 's tag name), Append(current input character,the temporary buffer))), (Anything else,List(Emit(U_003C,-1), Emit(U_002F,-1), Emit(a character token for each of the characters in the temporary buffer,-1), Reconsume(Script_data_escaped_state))))), Script_data_double_escape_start_state -> pState(Script_data_double_escape_start_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1))))), (U+000A LINE FEED (LF),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1))))), (U+000C FORM FEED (FF),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1))))), (U+0020 SPACE,List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1))))), (U+002F SOLIDUS (/),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1))))), (U+003E GREATER-THAN SIGN (&gt;),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_double_escaped_state)),List(Switch(Script_data_escaped_state), Emit(current input character as a character token,-1))))), (ASCII upper alpha,List(Append(the lowercase version of the current input character,the temporary buffer), Emit(current input character as a character token,6))), (ASCII lower alpha,List(Append(current input character,the temporary buffer), Emit(current input character as a character token,5))), (Anything else,List(Reconsume(Script_data_escaped_state))))), Script_data_double_escaped_state -> pState(Script_data_double_escaped_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Script_data_double_escaped_dash_state), Emit(U_002D,-1))), (U+003C LESS-THAN SIGN (&lt;),List(Switch(Script_data_double_escaped_less_than_sign_state), Emit(U_003C,-1))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Emit(U_FFFD,-1))), (EOF,List(Error(eof_in_script_html_comment_like_text parse error), Emit(end_of_file token,-1))), (Anything else,List(Emit(current input character as a character token,-1))))), Script_data_double_escaped_dash_state -> pState(Script_data_double_escaped_dash_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Script_data_double_escaped_dash_dash_state), Emit(U_002D,-1))), (U+003C LESS-THAN SIGN (&lt;),List(Switch(Script_data_double_escaped_less_than_sign_state), Emit(U_003C,-1))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Switch(Script_data_double_escaped_state), Emit(U_FFFD,-1))), (EOF,List(Error(eof_in_script_html_comment_like_text parse error), Emit(end_of_file token,-1))), (Anything else,List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1))))), Script_data_double_escaped_dash_dash_state -> pState(Script_data_double_escaped_dash_dash_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Emit(U_002D,-1))), (U+003C LESS-THAN SIGN (&lt;),List(Switch(Script_data_double_escaped_less_than_sign_state), Emit(U_003C,-1))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Script_data_state), Emit(U_003E,-1))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Switch(Script_data_double_escaped_state), Emit(U_FFFD,-1))), (EOF,List(Error(eof_in_script_html_comment_like_text parse error), Emit(end_of_file token,-1))), (Anything else,List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1))))), Script_data_double_escaped_less_than_sign_state -> pState(Script_data_double_escaped_less_than_sign_state,List(Consume(next input character)),List((U+002F SOLIDUS (/),List(Set(the temporary buffer,the empty string), Switch(Script_data_double_escape_end_state), Emit(U_002F,-1))), (Anything else,List(Reconsume(Script_data_double_escaped_state))))), Script_data_double_escape_end_state -> pState(Script_data_double_escape_end_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1))))), (U+000A LINE FEED (LF),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1))))), (U+000C FORM FEED (FF),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1))))), (U+0020 SPACE,List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1))))), (U+002F SOLIDUS (/),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1))))), (U+003E GREATER-THAN SIGN (&gt;),List(If(IsEqual(the temporary buffer,the string " script "),List(Switch(Script_data_escaped_state)),List(Switch(Script_data_double_escaped_state), Emit(current input character as a character token,-1))))), (ASCII upper alpha,List(Append(the lowercase version of the current input character,the temporary buffer), Emit(current input character as a character token,6))), (ASCII lower alpha,List(Append(current input character,the temporary buffer), Emit(current input character as a character token,5))), (Anything else,List(Reconsume(Script_data_double_escaped_state))))), Before_attribute_name_state -> pState(Before_attribute_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Ignore(character))), (U+000A LINE FEED (LF),List(Ignore(character))), (U+000C FORM FEED (FF),List(Ignore(character))), (U+0020 SPACE,List(Ignore(character))), (U+002F SOLIDUS (/),List(Reconsume(After_attribute_name_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Reconsume(After_attribute_name_state))), (EOF,List(Reconsume(After_attribute_name_state))), (U+003D EQUALS SIGN (=),List(Error(unexpected_equals_sign_before_attribute_name parse error), Start(), Set(that attribute 's name,the current input character), Set(its value,the empty string), Switch(Attribute_name_state))), (Anything else,List(Start(), Set(that attribute 's name and value,the empty string), Reconsume(Attribute_name_state))))), Attribute_name_state -> pState(Attribute_name_state,List(),List((U+0009 CHARACTER TABULATION (tab),List(Reconsume(After_attribute_name_state))), (U+000A LINE FEED (LF),List(Reconsume(After_attribute_name_state))), (U+000C FORM FEED (FF),List(Reconsume(After_attribute_name_state))), (U+0020 SPACE,List(Reconsume(After_attribute_name_state))), (U+002F SOLIDUS (/),List(Reconsume(After_attribute_name_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Reconsume(After_attribute_name_state))), (EOF,List(Reconsume(After_attribute_name_state))), (U+003D EQUALS SIGN (=),List(Switch(Before_attribute_value_state))), (ASCII upper alpha,List(Append(the lowercase version of the current input character,the current attribute 's name))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current attribute 's name))), (U+0022 QUOTATION MARK ("),List(Error(unexpected_character_in_attribute_name parse error), Treat())), (U+0027 APOSTROPHE ('),List(Error(unexpected_character_in_attribute_name parse error), Treat())), (U+003C LESS-THAN SIGN (&lt;),List(Error(unexpected_character_in_attribute_name parse error), Treat())), (Anything else,List(Append(current input character,the current attribute 's name))))), After_attribute_name_state -> pState(After_attribute_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Ignore(character))), (U+000A LINE FEED (LF),List(Ignore(character))), (U+000C FORM FEED (FF),List(Ignore(character))), (U+0020 SPACE,List(Ignore(character))), (U+002F SOLIDUS (/),List(Switch(Self_closing_start_tag_state))), (U+003D EQUALS SIGN (=),List(Switch(Before_attribute_value_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(current tag token,-1))), (EOF,List(Error(eof_in_tag parse error), Emit(end_of_file token,-1))), (Anything else,List(Start(), Set(that attribute 's name and value,the empty string), Reconsume(Attribute_name_state))))), Before_attribute_value_state -> pState(Before_attribute_value_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Ignore(character))), (U+000A LINE FEED (LF),List(Ignore(character))), (U+000C FORM FEED (FF),List(Ignore(character))), (U+0020 SPACE,List(Ignore(character))), (U+0022 QUOTATION MARK ("),List(Switch(Attribute_value_double_quoted_state))), (U+0027 APOSTROPHE ('),List(Switch(Attribute_value_single_quoted_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(missing_attribute_value parse error), Switch(Data_state), Emit(current tag token,-1))), (Anything else,List(Reconsume(Attribute_value_unquoted_state))))), Attribute_value_double_quoted_state -> pState(Attribute_value_double_quoted_state,List(Consume(next input character)),List((U+0022 QUOTATION MARK ("),List(Switch(After_attribute_value_quoted_state))), (U+0026 AMPERSAND (&amp;),List(Set(the return state,the Attribute_value_double_quoted_state), Switch(Character_reference_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current attribute 's value))), (EOF,List(Error(eof_in_tag parse error), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the current attribute 's value))))), Attribute_value_single_quoted_state -> pState(Attribute_value_single_quoted_state,List(Consume(next input character)),List((U+0027 APOSTROPHE ('),List(Switch(After_attribute_value_quoted_state))), (U+0026 AMPERSAND (&amp;),List(Set(the return state,the Attribute_value_single_quoted_state), Switch(Character_reference_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current attribute 's value))), (EOF,List(Error(eof_in_tag parse error), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the current attribute 's value))))), Attribute_value_unquoted_state -> pState(Attribute_value_unquoted_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Switch(Before_attribute_name_state))), (U+000A LINE FEED (LF),List(Switch(Before_attribute_name_state))), (U+000C FORM FEED (FF),List(Switch(Before_attribute_name_state))), (U+0020 SPACE,List(Switch(Before_attribute_name_state))), (U+0026 AMPERSAND (&amp;),List(Set(the return state,the Attribute_value_unquoted_state), Switch(Character_reference_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(current tag token,-1))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current attribute 's value))), (U+0022 QUOTATION MARK ("),List(Error(unexpected_character_in_unquoted_attribute_value parse error), Treat())), (U+0027 APOSTROPHE ('),List(Error(unexpected_character_in_unquoted_attribute_value parse error), Treat())), (U+003C LESS-THAN SIGN (&lt;),List(Error(unexpected_character_in_unquoted_attribute_value parse error), Treat())), (U+003D EQUALS SIGN (=),List(Error(unexpected_character_in_unquoted_attribute_value parse error), Treat())), (U+0060 GRAVE ACCENT (`),List(Error(unexpected_character_in_unquoted_attribute_value parse error), Treat())), (EOF,List(Error(eof_in_tag parse error), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the current attribute 's value))))), After_attribute_value_quoted_state -> pState(After_attribute_value_quoted_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Switch(Before_attribute_name_state))), (U+000A LINE FEED (LF),List(Switch(Before_attribute_name_state))), (U+000C FORM FEED (FF),List(Switch(Before_attribute_name_state))), (U+0020 SPACE,List(Switch(Before_attribute_name_state))), (U+002F SOLIDUS (/),List(Switch(Self_closing_start_tag_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(current tag token,-1))), (EOF,List(Error(eof_in_tag parse error), Emit(end_of_file token,-1))), (Anything else,List(Error(missing_whitespace_between_attributes parse error), Reconsume(Before_attribute_name_state))))), Self_closing_start_tag_state -> pState(Self_closing_start_tag_state,List(Consume(next input character)),List((U+003E GREATER-THAN SIGN (&gt;),List(Set(the self_closing flag of the current tag token,on), Switch(Data_state), Emit(current tag token,8))), (EOF,List(Error(eof_in_tag parse error), Emit(end_of_file token,-1))), (Anything else,List(Error(unexpected_solidus_in_tag parse error), Reconsume(Before_attribute_name_state))))), Bogus_comment_state -> pState(Bogus_comment_state,List(Consume(next input character)),List((U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(comment token,-1))), (EOF,List(Emit(comment,-1), Emit(end_of_file token,-1))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the comment token 's data))), (Anything else,List(Append(current input character,the comment token 's data))))), Markup_declaration_open_state -> pState(Markup_declaration_open_state,List(),List((Two U+002D HYPHEN-MINUS characters (-),List(Consume(two characters), Create(a comment token whose data is the empty string,-1), Switch(Comment_start_state))), (ASCII case-insensitive match for the word "DOCTYPE",List(Consume(characters), Switch(DOCTYPE_state))), (The string "[CDATA[" (the five uppercase letters "CDATA" with a U+005B LEFT SQUARE BRACKET character before and after),List(Consume(characters), If(And(IsExist(an adjusted current node),Not(IsEqual(it,an element in the HTML namespace))),List(Switch(CDATA_section_state)),List(Error(cdata_in_html_content parse error), Create(a comment token whose data is the " [ CDATA [ " string,-1), Switch(Bogus_comment_state))))), (Anything else,List(Error(incorrectly_opened_comment parse error), Create(a comment token whose data is the empty string,-1), Switch(Bogus_comment_state))))), Comment_start_state -> pState(Comment_start_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Comment_start_dash_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(abrupt_closing_of_empty_comment parse error), Switch(Data_state), Emit(comment token,-1))), (Anything else,List(Reconsume(Comment_state))))), Comment_start_dash_state -> pState(Comment_start_dash_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Comment_end_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(abrupt_closing_of_empty_comment parse error), Switch(Data_state), Emit(comment token,-1))), (EOF,List(Error(eof_in_comment parse error), Emit(comment token,-1), Emit(end_of_file token,-1))), (Anything else,List(Append(a U_002D HYPHEN_MINUS character,the comment token 's data), Reconsume(Comment_state))))), Comment_state -> pState(Comment_state,List(Consume(next input character)),List((U+003C LESS-THAN SIGN (&lt;),List(Append(current input character,the comment token 's data), Switch(Comment_less_than_sign_state))), (U+002D HYPHEN-MINUS (-),List(Switch(Comment_end_dash_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the comment token 's data))), (EOF,List(Error(eof_in_comment parse error), Emit(comment token,-1), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the comment token 's data))))), Comment_less_than_sign_state -> pState(Comment_less_than_sign_state,List(Consume(next input character)),List((U+0021 EXCLAMATION MARK (!),List(Append(current input character,the comment token 's data), Switch(Comment_less_than_sign_bang_state))), (U+003C LESS-THAN SIGN (&lt;),List(Append(current input character,the comment token 's data))), (Anything else,List(Reconsume(Comment_state))))), Comment_less_than_sign_bang_state -> pState(Comment_less_than_sign_bang_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Comment_less_than_sign_bang_dash_state))), (Anything else,List(Reconsume(Comment_state))))), Comment_less_than_sign_bang_dash_state -> pState(Comment_less_than_sign_bang_dash_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Comment_less_than_sign_bang_dash_dash_state))), (Anything else,List(Reconsume(Comment_end_dash_state))))), Comment_less_than_sign_bang_dash_dash_state -> pState(Comment_less_than_sign_bang_dash_dash_state,List(Consume(next input character)),List((U+003E GREATER-THAN SIGN (&gt;),List(Reconsume(Comment_end_state))), (EOF,List(Reconsume(Comment_end_state))), (Anything else,List(Error(nested_comment parse error), Reconsume(Comment_end_state))))), Comment_end_dash_state -> pState(Comment_end_dash_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Switch(Comment_end_state))), (EOF,List(Error(eof_in_comment parse error), Emit(comment token,-1), Emit(end_of_file token,-1))), (Anything else,List(Append(a U_002D HYPHEN_MINUS character,the comment token 's data), Reconsume(Comment_state))))), Comment_end_state -> pState(Comment_end_state,List(Consume(next input character)),List((U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(comment token,-1))), (U+0021 EXCLAMATION MARK (!),List(Switch(Comment_end_bang_state))), (U+002D HYPHEN-MINUS (-),List(Append(a U_002D HYPHEN_MINUS character,the comment token 's data))), (EOF,List(Error(eof_in_comment parse error), Emit(comment token,-1), Emit(end_of_file token,-1))), (Anything else,List(Append(two U_002D HYPHEN_MINUS characters,the comment token 's data), Reconsume(Comment_state))))), Comment_end_bang_state -> pState(Comment_end_bang_state,List(Consume(next input character)),List((U+002D HYPHEN-MINUS (-),List(Append(two U_002D HYPHEN_MINUS characters,the comment token 's data), Append(a U_0021 EXCLAMATION MARK character,the comment token 's data), Switch(Comment_end_dash_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(incorrectly_closed_comment parse error), Switch(Data_state), Emit(comment token,-1))), (EOF,List(Error(eof_in_comment parse error), Emit(comment token,-1), Emit(end_of_file token,-1))), (Anything else,List(Append(two U_002D HYPHEN_MINUS characters,the comment token 's data), Append(a U_0021 EXCLAMATION MARK character,the comment token 's data), Reconsume(Comment_state))))), DOCTYPE_state -> pState(DOCTYPE_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Switch(Before_DOCTYPE_name_state))), (U+000A LINE FEED (LF),List(Switch(Before_DOCTYPE_name_state))), (U+000C FORM FEED (FF),List(Switch(Before_DOCTYPE_name_state))), (U+0020 SPACE,List(Switch(Before_DOCTYPE_name_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Reconsume(Before_DOCTYPE_name_state))), (EOF,List(Error(eof_in_doctype parse error), Create(new DOCTYPE token,5), Set(its force_quirks flag,on), Emit(token,5), Emit(end_of_file token,-1))), (Anything else,List(Error(missing_whitespace_before_doctype_name parse error), Reconsume(Before_DOCTYPE_name_state))))), Before_DOCTYPE_name_state -> pState(Before_DOCTYPE_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Ignore(character))), (U+000A LINE FEED (LF),List(Ignore(character))), (U+000C FORM FEED (FF),List(Ignore(character))), (U+0020 SPACE,List(Ignore(character))), (ASCII upper alpha,List(Create(new DOCTYPE token,4), Set(the token 's name,the lowercase version of the current input character), Switch(DOCTYPE_name_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Create(new DOCTYPE token,4), Set(the token 's name,a U_FFFD REPLACEMENT CHARACTER character), Switch(DOCTYPE_name_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(missing_doctype_name parse error), Create(new DOCTYPE token,5), Set(its force_quirks flag,on), Switch(Data_state), Emit(token,5))), (EOF,List(Error(eof_in_doctype parse error), Create(new DOCTYPE token,5), Set(its force_quirks flag,on), Emit(token,5), Emit(end_of_file token,-1))), (Anything else,List(Create(new DOCTYPE token,3), Set(the token 's name,the current input character), Switch(DOCTYPE_name_state))))), DOCTYPE_name_state -> pState(DOCTYPE_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Switch(After_DOCTYPE_name_state))), (U+000A LINE FEED (LF),List(Switch(After_DOCTYPE_name_state))), (U+000C FORM FEED (FF),List(Switch(After_DOCTYPE_name_state))), (U+0020 SPACE,List(Switch(After_DOCTYPE_name_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(current DOCTYPE token,-1))), (ASCII upper alpha,List(Append(the lowercase version of the current input character,the current DOCTYPE token 's name))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's name))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the current DOCTYPE token 's name))))), After_DOCTYPE_name_state -> pState(After_DOCTYPE_name_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Ignore(character))), (U+000A LINE FEED (LF),List(Ignore(character))), (U+000C FORM FEED (FF),List(Ignore(character))), (U+0020 SPACE,List(Ignore(character))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(current DOCTYPE token,-1))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(If(IsEqual(the six characters starting from the current input character,an ASCII case_insensitive match for the word " PUBLIC "),List(Consume(characters), Switch(After_DOCTYPE_public_keyword_state)),List(If(IsEqual(the six characters starting from the current input character,an ASCII case_insensitive match for the word " SYSTEM "),List(Consume(characters), Switch(After_DOCTYPE_system_keyword_state)),List(Error(invalid_character_sequence_after_doctype_name parse error), Set(the DOCTYPE token 's force_quirks flag,on), Reconsume(Bogus_DOCTYPE_state))))))))), After_DOCTYPE_public_keyword_state -> pState(After_DOCTYPE_public_keyword_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Switch(Before_DOCTYPE_public_identifier_state))), (U+000A LINE FEED (LF),List(Switch(Before_DOCTYPE_public_identifier_state))), (U+000C FORM FEED (FF),List(Switch(Before_DOCTYPE_public_identifier_state))), (U+0020 SPACE,List(Switch(Before_DOCTYPE_public_identifier_state))), (U+0022 QUOTATION MARK ("),List(Error(missing_whitespace_after_doctype_public_keyword parse error), Set(the DOCTYPE token 's public identifier,the empty string), Switch(DOCTYPE_public_identifier_double_quoted_state))), (U+0027 APOSTROPHE ('),List(Error(missing_whitespace_after_doctype_public_keyword parse error), Set(the DOCTYPE token 's public identifier,the empty string), Switch(DOCTYPE_public_identifier_single_quoted_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(missing_doctype_public_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Switch(Data_state), Emit(DOCTYPE token,10))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Error(missing_quote_before_doctype_public_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Reconsume(Bogus_DOCTYPE_state))))), Before_DOCTYPE_public_identifier_state -> pState(Before_DOCTYPE_public_identifier_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Ignore(character))), (U+000A LINE FEED (LF),List(Ignore(character))), (U+000C FORM FEED (FF),List(Ignore(character))), (U+0020 SPACE,List(Ignore(character))), (U+0022 QUOTATION MARK ("),List(Set(the DOCTYPE token 's public identifier,the empty string), Switch(DOCTYPE_public_identifier_double_quoted_state))), (U+0027 APOSTROPHE ('),List(Set(the DOCTYPE token 's public identifier,the empty string), Switch(DOCTYPE_public_identifier_single_quoted_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(missing_doctype_public_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Switch(Data_state), Emit(DOCTYPE token,10))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Error(missing_quote_before_doctype_public_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Reconsume(Bogus_DOCTYPE_state))))), DOCTYPE_public_identifier_double_quoted_state -> pState(DOCTYPE_public_identifier_double_quoted_state,List(Consume(next input character)),List((U+0022 QUOTATION MARK ("),List(Switch(After_DOCTYPE_public_identifier_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's public identifier))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(abrupt_doctype_public_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Switch(Data_state), Emit(DOCTYPE token,11))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the current DOCTYPE token 's public identifier))))), DOCTYPE_public_identifier_single_quoted_state -> pState(DOCTYPE_public_identifier_single_quoted_state,List(Consume(next input character)),List((U+0027 APOSTROPHE ('),List(Switch(After_DOCTYPE_public_identifier_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's public identifier))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(abrupt_doctype_public_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Switch(Data_state), Emit(DOCTYPE token,11))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the current DOCTYPE token 's public identifier))))), After_DOCTYPE_public_identifier_state -> pState(After_DOCTYPE_public_identifier_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Switch(Between_DOCTYPE_public_and_system_identifiers_state))), (U+000A LINE FEED (LF),List(Switch(Between_DOCTYPE_public_and_system_identifiers_state))), (U+000C FORM FEED (FF),List(Switch(Between_DOCTYPE_public_and_system_identifiers_state))), (U+0020 SPACE,List(Switch(Between_DOCTYPE_public_and_system_identifiers_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(current DOCTYPE token,-1))), (U+0022 QUOTATION MARK ("),List(Error(missing_whitespace_between_doctype_public_and_system_identifiers parse error), Set(the DOCTYPE token 's system identifier,the empty string), Switch(DOCTYPE_system_identifier_double_quoted_state))), (U+0027 APOSTROPHE ('),List(Error(missing_whitespace_between_doctype_public_and_system_identifiers parse error), Set(the DOCTYPE token 's system identifier,the empty string), Switch(DOCTYPE_system_identifier_single_quoted_state))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Error(missing_quote_before_doctype_system_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Reconsume(Bogus_DOCTYPE_state))))), Between_DOCTYPE_public_and_system_identifiers_state -> pState(Between_DOCTYPE_public_and_system_identifiers_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Ignore(character))), (U+000A LINE FEED (LF),List(Ignore(character))), (U+000C FORM FEED (FF),List(Ignore(character))), (U+0020 SPACE,List(Ignore(character))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(current DOCTYPE token,-1))), (U+0022 QUOTATION MARK ("),List(Set(the DOCTYPE token 's system identifier,the empty string), Switch(DOCTYPE_system_identifier_double_quoted_state))), (U+0027 APOSTROPHE ('),List(Set(the DOCTYPE token 's system identifier,the empty string), Switch(DOCTYPE_system_identifier_single_quoted_state))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Error(missing_quote_before_doctype_system_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Reconsume(Bogus_DOCTYPE_state))))), After_DOCTYPE_system_keyword_state -> pState(After_DOCTYPE_system_keyword_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Switch(Before_DOCTYPE_system_identifier_state))), (U+000A LINE FEED (LF),List(Switch(Before_DOCTYPE_system_identifier_state))), (U+000C FORM FEED (FF),List(Switch(Before_DOCTYPE_system_identifier_state))), (U+0020 SPACE,List(Switch(Before_DOCTYPE_system_identifier_state))), (U+0022 QUOTATION MARK ("),List(Error(missing_whitespace_after_doctype_system_keyword parse error), Set(the DOCTYPE token 's system identifier,the empty string), Switch(DOCTYPE_system_identifier_double_quoted_state))), (U+0027 APOSTROPHE ('),List(Error(missing_whitespace_after_doctype_system_keyword parse error), Set(the DOCTYPE token 's system identifier,the empty string), Switch(DOCTYPE_system_identifier_single_quoted_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(missing_doctype_system_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Switch(Data_state), Emit(DOCTYPE token,10))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Error(missing_quote_before_doctype_system_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Reconsume(Bogus_DOCTYPE_state))))), Before_DOCTYPE_system_identifier_state -> pState(Before_DOCTYPE_system_identifier_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Ignore(character))), (U+000A LINE FEED (LF),List(Ignore(character))), (U+000C FORM FEED (FF),List(Ignore(character))), (U+0020 SPACE,List(Ignore(character))), (U+0022 QUOTATION MARK ("),List(Set(the DOCTYPE token 's system identifier,the empty string), Switch(DOCTYPE_system_identifier_double_quoted_state))), (U+0027 APOSTROPHE ('),List(Set(the DOCTYPE token 's system identifier,the empty string), Switch(DOCTYPE_system_identifier_single_quoted_state))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(missing_doctype_system_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Switch(Data_state), Emit(DOCTYPE token,10))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Error(missing_quote_before_doctype_system_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Reconsume(Bogus_DOCTYPE_state))))), DOCTYPE_system_identifier_double_quoted_state -> pState(DOCTYPE_system_identifier_double_quoted_state,List(Consume(next input character)),List((U+0022 QUOTATION MARK ("),List(Switch(After_DOCTYPE_system_identifier_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's system identifier))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(abrupt_doctype_system_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Switch(Data_state), Emit(DOCTYPE token,11))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the current DOCTYPE token 's system identifier))))), DOCTYPE_system_identifier_single_quoted_state -> pState(DOCTYPE_system_identifier_single_quoted_state,List(Consume(next input character)),List((U+0027 APOSTROPHE ('),List(Switch(After_DOCTYPE_system_identifier_state))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Append(U_FFFD REPLACEMENT CHARACTER character,the current DOCTYPE token 's system identifier))), (U+003E GREATER-THAN SIGN (&gt;),List(Error(abrupt_doctype_system_identifier parse error), Set(the DOCTYPE token 's force_quirks flag,on), Switch(Data_state), Emit(DOCTYPE token,11))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Append(current input character,the current DOCTYPE token 's system identifier))))), After_DOCTYPE_system_identifier_state -> pState(After_DOCTYPE_system_identifier_state,List(Consume(next input character)),List((U+0009 CHARACTER TABULATION (tab),List(Ignore(character))), (U+000A LINE FEED (LF),List(Ignore(character))), (U+000C FORM FEED (FF),List(Ignore(character))), (U+0020 SPACE,List(Ignore(character))), (U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(current DOCTYPE token,-1))), (EOF,List(Error(eof_in_doctype parse error), Set(the DOCTYPE token 's force_quirks flag,on), Emit(DOCTYPE token,8), Emit(end_of_file token,-1))), (Anything else,List(Error(unexpected_character_after_doctype_system_identifier parse error), Reconsume(Bogus_DOCTYPE_state))))), Bogus_DOCTYPE_state -> pState(Bogus_DOCTYPE_state,List(Consume(next input character)),List((U+003E GREATER-THAN SIGN (&gt;),List(Switch(Data_state), Emit(DOCTYPE token,-1))), (U+0000 NULL,List(Error(unexpected_null_character parse error), Ignore(character))), (EOF,List(Emit(DOCTYPE token,-1), Emit(end_of_file token,-1))), (Anything else,List(Ignore(character))))), CDATA_section_state -> pState(CDATA_section_state,List(),List((U+005D RIGHT SQUARE BRACKET (]),List(Switch(CDATA_section_bracket_state))), (EOF,List(Error(eof_in_cdata parse error), Emit(end_of_file token,-1))), (Anything else,List(Emit(current input character as a character token,-1))))), CDATA_section_bracket_state -> pState(CDATA_section_bracket_state,List(Consume(next input character)),List((U+005D RIGHT SQUARE BRACKET (]),List(Switch(CDATA_section_end_state))), (Anything else,List(Emit(U_005D,-1), Reconsume(CDATA_section_state))))), CDATA_section_end_state -> pState(CDATA_section_end_state,List(Consume(next input character)),List((U+005D RIGHT SQUARE BRACKET (]),List(Emit(U_005D,-1))), (U+003E GREATER-THAN SIGN character,List(Switch(Data_state))), (Anything else,List(Emit(two U_005Ds,-1), Reconsume(CDATA_section_state))))), Character_reference_state -> pState(Character_reference_state,List(Set(the temporary buffer,the empty string), Append(U_0026 AMPERSAND character,the temporary buffer), Consume(next input character)),List((ASCII alphanumeric,List(Reconsume(Named_character_reference_state))), (U+0023 NUMBER SIGN (#),List(Append(current input character,the temporary buffer), Switch(Numeric_character_reference_state))), (Anything else,List(Flush(), Reconsume(return state))))), Named_character_reference_state -> pState(Named_character_reference_state,List(),List((If there is a match,List(If(UNDEF(the character reference was consumed as part of an attribute , and the last character matched is not a U_003B SEMICOLON character ( ;) , and the next input character is either a U_003D EQUALS SIGN character ( =) or an ASCII alphanumeric),List(Switch(return state)),List()))), (Otherwise,List(Flush(), Switch(Ambiguous_ampersand_state))))), Ambiguous_ampersand_state -> pState(Ambiguous_ampersand_state,List(Consume(next input character)),List((ASCII alphanumeric,List(If(UNDEF(the character reference was consumed as part of an attribute),List(Append(current input character,the current attribute 's value)),List(Emit(current input character as a character token,11))))), (U+003B SEMICOLON (;),List(Error(unknown_named_character_reference parse error), Reconsume(return state))), (Anything else,List(Reconsume(return state))))), Numeric_character_reference_state -> pState(Numeric_character_reference_state,List(Set(the character reference code,zero), Consume(next input character)),List((U+0078 LATIN SMALL LETTER X,List(Append(current input character,the temporary buffer), Switch(Hexadecimal_character_reference_start_state))), (U+0058 LATIN CAPITAL LETTER X,List(Append(current input character,the temporary buffer), Switch(Hexadecimal_character_reference_start_state))), (Anything else,List(Reconsume(Decimal_character_reference_start_state))))), Hexadecimal_character_reference_start_state -> pState(Hexadecimal_character_reference_start_state,List(Consume(next input character)),List((ASCII hex digit,List(Reconsume(Hexadecimal_character_reference_state))), (Anything else,List(Error(absence_of_digits_in_numeric_character_reference parse error), Flush(), Reconsume(return state))))), Decimal_character_reference_start_state -> pState(Decimal_character_reference_start_state,List(Consume(next input character)),List((ASCII digit,List(Reconsume(Decimal_character_reference_state))), (Anything else,List(Error(absence_of_digits_in_numeric_character_reference parse error), Flush(), Reconsume(return state))))), Hexadecimal_character_reference_state -> pState(Hexadecimal_character_reference_state,List(Consume(next input character)),List((ASCII digit,List(Multiply(character reference code,16), Add(a numeric version of the current input character,the character reference code))), (ASCII upper hex digit,List(Multiply(character reference code,16), Add(a numeric version of the current input character as a hexadecimal digit,the character reference code))), (ASCII lower hex digit,List(Multiply(character reference code,16), Add(a numeric version of the current input character as a hexadecimal digit,the character reference code))), (U+003B SEMICOLON,List(Switch(numeric character reference end state))), (Anything else,List(Error(missing_semicolon_after_character_reference parse error), Reconsume(numeric character reference end state))))), Decimal_character_reference_state -> pState(Decimal_character_reference_state,List(Consume(next input character)),List((ASCII digit,List(Multiply(character reference code,10), Add(a numeric version of the current input character,the character reference code))), (U+003B SEMICOLON,List(Switch(numeric character reference end state))), (Anything else,List(Error(missing_semicolon_after_character_reference parse error), Reconsume(numeric character reference end state))))))

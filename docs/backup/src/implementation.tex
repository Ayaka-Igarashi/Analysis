\documentclass[uplatex,a4j]{jsreport}
\usepackage{thesis}

\begin{document}
\chapter{実装}
\label{実装}
\ref{命令抽出}章でHTML5字句解析仕様から抽出し, 形式化したもの使ってHTML5の字句解析のインタプリタを作成した.
\section{実装の概観}
% インタープリタの概略図書く
\begin{figure}[h]
    \centering
    \includegraphics[keepaspectratio, scale=0.5]
         {figure/インタープリタ.png}
    \caption{インタープリタ概略}
    \label{interpret}
\end{figure}
形式化した命令をもとに動かす. 
\section{インタプリタの実装の詳細}
\subsection{文字マッチングの処理}
字句解析の定義と現在消費した文字(current inputCharacter)を受け取り, 
マッチした文字に対応する処理 Command型のリストを返す.
\subsection{CommandValue型の解釈}
CommandValue型と環境を受け取り, Value型を返す関数を実装した.
\subsubsection{Value型}
インタープリタで扱う値の型
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single, caption=Value型,label=Value][htbp]
    IntVal(int: Int)
    BooleanVal(boolean: Boolean)
    CharVal(c: Char)
    StringVal(string: String)
    EOFVal
    StateVal(statename: String)
    TokenVal(token: Token)
\end{lstlisting}
\subsection{Command型の解釈}
Command型と環境を受け取り, 新しい環境, 排出トークン, エラー内容を返す関数を実装した.

\section{実装の評価}
% 字句解析のインタプリターの正しさを検証するために, 
html5lib-tests~\cite{html5lib-tests}のtokenizerのテストデータを用い, インタープリタのテストを行った.
\subsection{HTML5字句解析テスト}
\begin{table}[htb]
    \begin{tabular}{|l|c|l|} \hline
      テストファイル名 & 結果 & テスト内容\\ \hline 
      contentModelFlags.test & 24/24 &  \\
      domjs.test & 57/58 &  \\
      entities.test & 80/80 & \&から始まる文字列の文字の参照が上手くいっているか\\
      escapeFlag.test & 9/9 & 偽のコメントトークンに対する処理\\
      namedEntities.test & 4210/4210 & named character referencesの表の参照が上手くいっているか\\
      numericEntities.test & 336/336 & character reference codeから文字への参照が上手くいっているか\\
      pendingSpecChanges.test & 1/1 & コメントトークン中にEOFトークンが出てきた場合のテスト\\
      test1.test & 68/68 & テスト1 \\
      test2.test & 35/45 & テスト2 \\
      test3.test & 1374/1786 & テスト3 \\
      test4.test & 81/85 & テスト4 \\
      unicodeChars.test & 323/323 & ユニコード表記の文字列が対応する文字に変換されているか\\
      unicodeCharsProblem.test & 5/5 & 不適切な場合のユニコードの処理が上手くいっているか\\ \hline 
    \end{tabular}
\end{table}

%思ったこと
Tag型からの命令抽出に関しては, 特殊な部分を逐一個別に対応していたので上手くいったと思われる.%手作業でやった部分が多いので上手くいったと思う.
\subsubsection*{domjsが上手くいかなかった原因}
% 入力文字列を字句解析器に通す前に, 入力文字列に対して文字の置き換えをする必要があった.
CDATAの部分の処理を実装していなかったため.

\subsection{問題点}
%上手くいかなかった点
% subsection*{test2.test,test3.test,test4.testが上手くいかなかった原因}
%正しく命令が抽出されたように思われても、正しくなかった例
If the six characters starting from the current input character are an ASCII case-insensitive match for the word ``PUBLIC'', then consume those characters
この文章を自然言語解析させると``those characters''は``the six characters starting from the current input character''を参照するという出力になる.\\
もし,この状態へ遷移した時点での入力文字列が``public $\cdots$''であったら,まず文字'p'を消費し,入力文字列が``ublic $\cdots$''となる.\\
機械的にこの文章を処理しようとすると,現在の入力文字列``ublic $\cdots$''から文字列``public''を消費せよという解釈になるので,上手くいかない.\\
この問題を手動で解決させた結果,以下のようなテスト結果の改善が成された.\\
\begin{table}[htb]
    \begin{tabular}{|l|c|} \hline
      テストファイル名 & 結果 \\ \hline 
      domjs.test & 57/58 \\
      test2.test & 45/45 \\
      test3.test & 1786/1786 \\
      test4.test & 85/85 \\ \hline 
    \end{tabular}
\end{table}



% \section{字句解析器の変数}
% next state

% current state

% return state


% \section{Command型}
% 実装したCommand型のそれぞれの動作を操作的意味論を用いて表す. 
% \subsection*{Switch(state: CommandValue)}
% $\langle$ Switch(state), $env \rangle \rightarrow env[nextState \leftarrow \mathcal{I}_{cval}[\![state]\!] ]$

% \subsection*{Recomsume(state: CommandValue)}
% $\langle$ Recomsume(state), $env \rangle \rightarrow env[nextState \leftarrow \mathcal{I}_{cval}[\![state]\!] , {\rm inputText} \leftarrow {\rm char + inputText} ]$\\
%  if currentInputCharacter = CharVal(char)\\
% $\langle$ Recomsume(state), $env \rangle \rightarrow env[nextState \leftarrow \mathcal{I}_{cval}[\![state]\!] , {\rm inputText} \leftarrow {\rm string + inputText} ]$\\
%  if currentInputCharacter = StringVal(string)\\
% $\langle$ Recomsume(state), $env \rangle \rightarrow env[nextState \leftarrow \mathcal{I}_{cval}[\![state]\!] ]$\\
%  if currentInputCharacter = EOFVal\\

% \subsection*{Consume()}

% \subsection*{Consume()}

% \subsection*{Consume()}

% \subsection*{Consume()}

% \subsection*{Consume()}

% \subsection*{Consume()}

% \subsection*{Consume()}

% \subsection*{Consume()}

% \subsection*{Consume()}

% \subsection*{Consume()}

% \subsection*{If(bool: Bool, t: CommandList, f: CommandList)}
% \begin{prooftree}
%     \AxiomC{$\langle$ clist1, $env\rangle \rightarrow env^\prime $ }
%     \RightLabel{{\scriptsize if $\mathcal{B}[\![b]\!] = true$}}
%     \UnaryInfC{$\langle$if $b$ then clist1 else clist2, $env\rangle \rightarrow env^\prime$}
% \end{prooftree}
% \begin{prooftree}
%     \AxiomC{$\langle$ clist2, $env\rangle \rightarrow env^\prime $ }
%     \RightLabel{{\scriptsize if $\mathcal{B}[\![\mathcal{C}[\![b]\!]]\!] = false$}}
%     \UnaryInfC{$\langle$if $b$ then clist1 else clist2, $env\rangle \rightarrow env^\prime$}
% \end{prooftree}

% \section{Bool型}
% \subsection*{And(a: Bool, b: Bool)}
% \subsection*{CharacterReferenceConsumedAsAttributeVal()}
% \subsection*{CurrentEndTagIsAppropriate()}
% \subsection*{IsEqual(a: CommandValue, b: CommandValue)}

% \section{Token型}
% tagToken(isStart: Boolean, name: String, attributes: List[Attribute])
% DOCTYPEToken( systemIdentifier: String, publicIdentifier: String)
% characterToken()


% \section{CommandValue型}
% CommandValue型からValue型の値を返す関数\\
% $C : {\rm CommandValue} \rightarrow {\rm Value} $\\
% \subsection*{LowerCaseVersion(cVal: CommandValue)}
% c.toLowerCase if $C[\![$cVal$]\!] = $c: Char or String
% \subsection*{NumericVersion(cVal: CommandValue)}
% Integer.parseInt(c.toString, 16)
% \subsection*{NextInputCharacter}
% $
% \begin{cases}
%     {\rm CharVal(c)} & {\rm inputText.headOption} = {\rm Some(c)} \\
%     {\rm EOFVal} & {\rm inputText.headOption} = {\rm None}
% \end{cases}
% $
% \subsection*{CurrentInputCharacter}
% currentInputCharacter
% \subsection*{EndOfFileToken}
% TokenVal(endOfFileToken())

% \section{ImplementVariable型}
% $\mathcal{I}_{ival}$
% \subsection{IReturnState}
% returnState

\end{document}
\documentclass[uplatex,a4j]{jsreport}
\usepackage{thesis}

\begin{document}
\chapter{抽出の形式（モデル）}
\label{形式}
HTML5の仕様書から命令を抽出するため, BNFの記法を用いて, 命令を形式化する.
\section{1状態の目標とする形}%後ろに移動する

\section{抽出する命令の形式}
% 例：抽出する命令を形式化したいため, BNFで命令を定義した.
%BNFの形式を使って, 仕様書から抽出したい命令を形式化する.\\
% 仕様書において, 字句解析器の変数や値として出てくるもの
まず命令の形式の, メタ変数, 型を以下で定める.\\
\begin{alignat*}{3}%  &{\rm cList } & &{\rm : CommandList }&\quad&\cdots 命令文のリスト\\
  &{\rm c }& &{\rm : Command }&\quad &\cdots 命令文\\
  &{\rm b }& &{\rm : Bool }& &\cdots {\rm if}文の命令文の条件部分の文\\
  &{\rm cval }& &{\rm : CommandValue }& &\cdots 命令文が引数に持つ値\\
  &{\rm ival }& &{\rm : InplementVariable} & &\cdots 命令文が引数に持つ代入される変数の種類\\
\end{alignat*}
cval, ivalは仕様書において, 字句解析器の変数や値として出てくるものであり, ivalは代入される対象, cvalは代入するものを表している. \\
メタ変数は, c$_1$, c$_2$のように, 添え字つけられていてもよいものとする. \\

それぞれの型の構造は以下のように定める. \\
% \subsection*{CommandList型}
% \begin{eqnarray*}
%   {\rm cList }&\bnfdef& \mbox{ c :: cList} \bnfor \mbox{ cList$_1$ $++$ cList$_2$} \bnfor \mbox{ Nil}\\
% \end{eqnarray*}
% 実際の実装では単にScalaのList構造を用いている.
\subsection*{Command型}
%  if b then list$_1$: List[Command] else list$_2$: List[Command]
\begin{alignat*}{3}
  {\rm c }::&= &\quad&\mbox{ If(b, cList$_1$, cList$_2$)} &\quad&\mbox{ // if b then cList$_1$ else cList$_2$}\\
    &|& &\mbox{ Ignore()} & &\mbox{ // 何もしない処理} \\
    &|& &\mbox{ Switch(cval)} & &\mbox{ // 状態cvalへ遷移する} \\
    &|& &\mbox{ Reconsume(cval)} & &\mbox{ // 状態cvalへ遷移. この状態で消費した文字を,次の状態で再度消費する.} \\
    &|& &\mbox{ Set(ival, cval)} & &\mbox{ // ivalにcvalを代入する (ival $\leftarrow$ cval)} \\
    &|& &\mbox{ AppendTo(cval, ival)} & &\mbox{ // ivalにcvalを追加する (ival $\leftarrow$ ival + cval)} \\
    &|& &\mbox{ Emit(cval)} & &\mbox{ // トークンcvalを排出する} \\
    &|& &\mbox{ Create(string, cval)} & &\mbox{ // トークンcvalを新たに作り, 変数stringにトークンcvalを代入する} \\
    &|& &\mbox{ Consume(cval)} & &\mbox{ // 文字cvalを消費する} \\
    &|& &\mbox{ Error(string)} & &\mbox{ // エラーstringを排出する} \\
    &|& &\mbox{ FlushCodePoint()} & &\mbox{ // 一時バッファの内容を排出する} \\
    &|& &\mbox{ StartAttribute()} & &\mbox{ // 現在のtagTokenに新しい属性を加える} \\
    &|& &\mbox{ TreatAsAnythingElse()} & &\mbox{ // AnythingElseの処理内容を実行する} \\
    &|& &\mbox{ AddTo(cval, ival)} & &\mbox{ // ival $\leftarrow$ ival + cval } \\
    &|& &\mbox{ MultiplyBy(ival, cval)} & &\mbox{ // ival $\leftarrow$ ival * cval} \\
\end{alignat*}

% \begin{alignat*}{3}
%   {\rm c }::=& & &\mbox{ If(b, cList$_1$, cList$_2$)} & &\mbox{ // if b then cList$_1$ else cList$_2$}\\
%           &|& &\mbox{ Ignore()} & &\mbox{ // 何もしない} \\
% \end{alignat*}
% \begin{alignat}{2}
%   a &= b & \quad & \text{(定義)} \\
%     &= c &       & \text{(なんかすごい定理)}
%   \end{alignat}
% % \begin{eqnarray*}
% %   f(x) ::=&x^2+3x+ssssdddddd2  &// aa\\
% %   |&(x+1)(x+2)  &// ss\\
% %   |&(x+1)(x+2)aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa  &// ss
% % \end{eqnarray*}

% \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single, caption=Commandの定義,label=Tag][htbp]
%   trait Command
%   case class Ignore() extends Command // 何もしない
%   case class Switch(state: CommandValue) extends Command // 状態stateへ遷移する
%   case class Reconsume(state: CommandValue) extends Command // 状態stateへ遷移. この状態で消費した文字を,次の状態で再度消費する.
% \end{lstlisting}

% \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single, caption=Boolの定義,label=Tag][htbp]
%   case object T extends Bool
%   case object F extends Bool
%   case class And(a: Bool, b: Bool) extends Bool
%   case class Or(a: Bool, b: Bool) extends Bool
%   case class Not(a: Bool) extends Bool
%   case class CharacterReferenceConsumedAsAttributeVal() extends Bool // the character reference was consumed as part of an attribute
%   case class CurrentEndTagIsAppropriate() extends Bool
%   case class IsEqual(a: CommandValue, b: CommandValue) extends Bool // the temporary buffer is the string "script"
%   case class AsciiCaseInsensitiveMatch(a: CommandValue, b: CommandValue) extends Bool
% \end{lstlisting}

% \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single, caption=CommandValueの定義,label=Tag][htbp]
%   trait CommandValue
%   case class StateName(state: String) extends CommandValue
%   case object ReturnState extends CommandValue
%   case object TemporaryBuffer extends CommandValue
%   case object CharacterReferenceCode extends CommandValue

%   case object NewStartTagToken extends CommandValue
%   case object NewEndTagToken extends CommandValue
%   case object NewDOCTYPEToken extends CommandValue
%   case object NewCommentToken extends CommandValue

%   case object CurrentTagToken extends CommandValue
%   case object CurrentDOCTYPEToken extends CommandValue
%   case object CurrentAttribute extends CommandValue
%   case object CommentToken extends CommandValue
%   case object EndOfFileToken extends CommandValue
%   case class CharacterToken(chara: String) extends CommandValue

%   case class LowerCase(token: CommandValue) extends CommandValue
%   case class NumericVersion(token: CommandValue) extends CommandValue
%   case object CurrentInputCharacter extends CommandValue
%   case class NextInputCharacter(num: Int) extends CommandValue
%   case class CharactersFromCurrentInputCharacter(num: Int) extends CommandValue

%   case class Variable(variable: String) extends CommandValue
%   case class CChar(char: Char) extends CommandValue
%   case class CString(string: String) extends CommandValue
%   case class CInt(int: Int) extends CommandValue
%   case class CBool(boolean: Boolean) extends CommandValue

%   case class Substitute(variable: Variable, commandValue: CommandValue) extends CommandValue
% \end{lstlisting}

% \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single, caption=ImplementVariableの定義,label=Tag][htbp]
%   trait ImplementVariable
%   case object IReturnState extends ImplementVariable
%   case object ITemporaryBuffer extends ImplementVariable
%   case object ICharacterReferenceCode extends ImplementVariable
%   case object ICurrentTagToken extends ImplementVariable
%   case object ICurrentDOCTYPEToken extends ImplementVariable
%   case object ICurrentAttribute extends ImplementVariable
%   case object ICommentToken extends ImplementVariable
%   case class IVariable(variable: String) extends ImplementVariable
%   case class INameOf(token: ImplementVariable) extends ImplementVariable
%   case class IValueOf(token: ImplementVariable) extends ImplementVariable
%   case class IFlagOf(token: ImplementVariable) extends ImplementVariable
%   case class SystemIdentifierOf(token: ImplementVariable) extends ImplementVariable
%   case class PublicIdentifierOf(token: ImplementVariable) extends ImplementVariable
% \end{lstlisting}
\subsection*{Bool型}
\begin{alignat*}{3}
    {\rm b }::&= &\quad& \mbox{ And(b$_1$, b$_2$)} &\quad&\mbox{ // b$_1$ かつ b$_2$ である}\\
      &|& &\mbox{ Or(b$_1$, b$_2$)} & &\mbox{ // b$_1$ または b$_2$ である} \\
      &|& &\mbox{ Not(b)} & &\mbox{ // bでない} \\
      &|& &\mbox{ CharacterReferenceConsumedAsAttributeVal}()& & \mbox{ // CharacterReferenceCodeが属性の値として} \\
      & & & & &\mbox{ \hspace{12pt}消費されているか} \\
      &|& &\mbox{ CurrentEndTagIsAppropriate}()& & \mbox{ // EndTagTokenが適切なものであるか } \\
      &|& &\mbox{ IsEqual(cval$_1$, cval$_2$)} & &\mbox{ // cval$_1$とcval$_2$の値が等しい} \\
      &|& &\mbox{ AsciiCaseInsensitiveMatch(cval$_1$, cval$_2$)} & &\mbox{ // cval$_1$とcval$_2$が文字列であるとき, } \\
      & & & & &\mbox{ \hspace{12pt}大文字, 小文字の差を無視しcval$_1$とcval$_2$の値が等しい} \\
\end{alignat*}
\subsection*{CommandValue型}
\begin{alignat*}{3}
  {\rm cval }::&= &\quad& \mbox{ StateName(string)} &\quad&\mbox{ // 状態名string}\\
    &|& &\mbox{ ReturnState} & &\mbox{ // 字句解析器の変数 : return state} \\
    &|& &\mbox{ TemporaryBuffer} & &\mbox{ // 字句解析器の変数 : temporary buffer (一時バッファ)} \\
    &|& &\mbox{ CharacterReferenceCode} & &\mbox{ // 字句解析器の変数 : character reference code} \\
    &|& &\mbox{ NewStartTagToken} & &\mbox{ // 初期状態の開始タグトークン} \\
    &|& &\mbox{ NewEndTagToken} & &\mbox{ // 初期状態の終了タグトークン} \\
    &|& &\mbox{ NewDOCTYPEToken} & &\mbox{ // 初期状態のDOCTYPEトークン} \\
    &|& &\mbox{ NewCommentToken} & &\mbox{ // 初期状態のコメントトークン} \\
    &|& &\mbox{ CurrentTagToken} & &\mbox{ // 一番新しく作られたタグトークン} \\
    &|& &\mbox{ CurrentDOCTYPEToken} & &\mbox{ // 一番新しく作られたDOCTYPEトークン} \\
    &|& &\mbox{ CurrentAttribute} & &\mbox{ // 一番新しく作られたタグトークンの属性(attribute)} \\
    &|& &\mbox{ CommentToken} & &\mbox{ // 一番新しく作られたコメントトークン} \\
    &|& &\mbox{ EndOfFileToken} & &\mbox{ // EOFトークン} \\
    &|& &\mbox{ CharacterToken(cval)} & &\mbox{ // 中身がcvalの文字トークン} \\
    &|& &\mbox{ LowerCase(cval)} & &\mbox{ // cvalの小文字} \\
    &|& &\mbox{ NumericVersion(cval)} & &\mbox{ // 16進数表記されているcvalの数字としての値} \\
    &|& &\mbox{ CurrentInputCharacter} & &\mbox{ // 現在消費した文字} \\
    &|& &\mbox{ NextInputCharacter} & &\mbox{ // 入力文字列の一番最初の文字} \\
    &|& &\mbox{ Substitute(string, cval)} & &\mbox{ // cval\ (副作用として変数stringにcvalを代入する)} \\
    &|& &\mbox{ Variable(string)} & &\mbox{ // 変数string} \\
    &|& &\mbox{ CChar(char)} & &\mbox{ // Char型の値char} \\
    &|& &\mbox{ CString(string)} & &\mbox{ // String型の値string} \\
    &|& &\mbox{ CInt(int)} & &\mbox{ // Int型の値int} \\
    &|& &\mbox{ CBool(boolean)} & &\mbox{ // Boolean型の値boolean} \\
\end{alignat*}
\subsection*{InplementVariable型}
\begin{alignat*}{3}
  {\rm ival }::&= &\quad& \mbox{ IReturnState} &\quad&\mbox{ // 字句解析器の変数 : return state}\\
    &|& &\mbox{ ITemporaryBuffer} & &\mbox{ // 字句解析器の変数 : temporary buffer} \\
    &|& &\mbox{ ICharacterReferenceCode} & &\mbox{ // 字句解析器の変数 : character reference code} \\
    &|& &\mbox{ ICurrentTagToken} & &\mbox{ // 一番新しく作られたタグトークン} \\
    &|& &\mbox{ ICurrentDOCTYPEToken} & &\mbox{ // 一番新しく作られたDOCTYPEトークン} \\
    &|& &\mbox{ ICurrentAttribute} & &\mbox{ // 一番新しく作られたタグトークンの属性(attribute)} \\
    &|& &\mbox{ ICommentToken} & &\mbox{ // 一番新しく作られたコメントトークン} \\
    &|& &\mbox{ IVariable(string)} & &\mbox{ // 変数string} \\
    &|& &\mbox{ INameOf(ival)} & &\mbox{ // タグトークン, 属性であるivalの名前} \\
    &|& &\mbox{ IValueOf(ival)} & &\mbox{ // 属性ivalの値} \\
    &|& &\mbox{ IFlagOf(ival)} & &\mbox{ // DOCTYPE, タグトークンivalのフラグ} \\
    &|& &\mbox{ SystemIdentifierOf(ival)} & &\mbox{ // DOCTYPEトークンivalのシステム識別子} \\
    &|& &\mbox{ PublicIdentifierOf(ival)} & &\mbox{ // DOCTYPEトークンivalの公開識別子} \\
\end{alignat*}

string,char,int,booleanはそれぞれScalaの標準の型(String,Char,Int,Boolean)の値
\section{命令形式の例}
自然言語の文から, 上記の形式への変換の例をいくつか記す.\\

状態Data_stateへ遷移するという意味の文に関して, 

Switch to the Data_state.\\
%$\Rightarrow$ Switch(\underline{the Data_state})\\
$\Rightarrow$ Switch(StateName(Data_state))

状態名を意味するStateName(Data_state)というCommandValue型の値を持つ, Switchという遷移を意味するCommand型の値に変換する.\\

また, 現在のタグトークン名に, 現在消費した文字を小文字にしたものを付け足すという意味の文に関して, 

Append the lowercase version of the current input character to the current tag token's tag name.\\
$\Rightarrow$ Append(LowerCase(CurrentInputCharacter), INameOf(CurrentTagToken))

第1引数に``現在消費した文字の小文字''を意味するCommandValue型の値, 第2引数に``現在のタグトークン名''を意味するImplementVariable型の値を持つCommand型のAppendという値に変換される.\\

この自然言語の文章から上記の形式への変換の過程を\ref{自然言語処理}, \ref{命令抽出}章で説明していく.\\
% 自然言語処理の情報を取り出す過程を5章
% 取り出した情報からCommand型へ変換する過程を6章

% \begin{eqnarray*}
%     {\rm c }&::=& \mbox{if $\langle$Bool$\rangle$ then $\langle$cList$\rangle_1$ else $\langle$cList$\rangle_2$}\\
%       &|& \mbox{ Ignore() // 何もしない} \\
%       &|& \mbox{ Switch($\langle$CommandValue$\rangle$) // 状態cvalへ遷移する} \\
%       &|& \mbox{ Reconsume($\langle$CommandValue$\rangle$) // 状態cvalへ遷移. この状態で消費した文字を,次の状態で再度消費する.} \\
%       &|& \mbox{ Set(<ImplementVariable>, $\langle$CommandValue$\rangle$) // ivalにcvalを代入する(ival $\leftarrow$ cval)} \\
%       &|& \mbox{ AppendTo($\langle$CommandValue$\rangle$, <ImplementVariable>) // ivalにcvalを追加する(ival $\leftarrow$ ival + cval)} \\
%       &|& \mbox{ Emit($\langle$CommandValue$\rangle$) // トークンcvalを排出する} \\
%       &|& \mbox{ Create($\langle$CommandValue$\rangle$) // トークンcvalを新たに作る} \\
%       &|& \mbox{ Consume($\langle$CommandValue$\rangle$) // 文字cvalを消費する} \\
%       &|& \mbox{ Error(string) // エラーstringを排出する} \\
%       &|& \mbox{ FlushCodePoint() // 一時バッファの内容を排出する} \\
%       &|& \mbox{ StartAttribute() // 現在のtagTokenに新しい属性を加える} \\
%       &|& \mbox{ TreatAsAnythingElse() // AnythingElseの処理内容を実行する} \\
%       &|& \mbox{ AddTo($\langle$CommandValue$\rangle$, $\langle$ImplementVariable$\rangle$) 
%                 //$\langle$ImplementVariable$\rangle = \langle$ImplementVariable$\rangle + \langle$CommandValue$\rangle$ } \\
%       &|& \mbox{ MultiplyBy(<ImplementVariable>, $\langle$CommandValue$\rangle$)} \\
% \end{eqnarray*}
% \begin{eqnarray*}
%     {\rm <Bool> }&::=& And(<Bool>, <Bool>)\\
%       &|& Or(<Bool>, <Bool>) \\
%       &|& Not(<Bool>) \\
%       &|& CharacterReferenceConsumedAsAttributeVal() \\
%       &|& CurrentEndTagIsAppropriate() \\
%       &|& IsEqual(<CommandValue>, <CommandValue>) \\
% \end{eqnarray*}
% \begin{eqnarray*}
%     {\rm <CommandValue> }&::=& StateName(<String>)\\
%       &|& ReturnState \\
%       &|& TemporaryBuffer \\
%       &|& CharacterReferenceCode \\
%       &|& NewStartTagToken \\
%       &|& NewEndTagToken \\
%       &|& NewDOCTYPEToken \\
%       &|& NewCommentToken \\
%       &|& CurrentTagToken \\
%       &|& CurrentDOCTYPEToken \\
%       &|& CurrentAttribute \\
%       &|& CommentToken \\
%       &|& EndOfFileToken \\
%       &|& CharacterToken(<Char>) \\
%       &|& LowerCase(<CommandValue>) \\
%       &|& NumericVersion(<CommandValue>) \\
%       &|& CurrentInputCharacter \\
%       &|& NextInputCharacter \\
%       &|& Variable(<String>) \\
%       &|& CChar(<Char>) \\
%       &|& CString(<String>) \\
%       &|& CInt(<Int>) \\
%       &|& CBool(<Boolean>) \\
% \end{eqnarray*}
% \begin{eqnarray*}
%     {\rm <ImplementVariable> }&::=& IReturnState\\
%       &|& ITemporaryBuffer \\
%       &|& ICharacterReferenceCode \\
%       &|& ICurrentTagToken \\
%       &|& ICurrentDOCTYPEToken \\
%       &|& ICurrentAttribute \\
%       &|& ICommentToken \\
%       &|& IVariable(<String>) \\
%       &|& INameOf(<ImplementVariable>) \\
%       &|& IValueOf(<ImplementVariable>) \\
%       &|& IFlagOf(<ImplementVariable>) \\
%       &|& SystemIdentifierOf(<ImplementVariable>) \\
%       &|& PublicIdentifierOf(<ImplementVariable>) \\
% \end{eqnarray*}
\end{document}